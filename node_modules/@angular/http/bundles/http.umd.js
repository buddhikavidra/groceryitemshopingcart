/**
 * @license Angular v2.4.10
 * (c) 2010-2017 Google, Inc. https://angular.io/
 * License: MIT
 */
(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('@angular/core'),exports, require('@angular/core'), require('rxjs/Observable'), require('@angular/platform-browser')) :
    typeof define === 'function' && define.amd ? define(['@angular/core','exports', '@angular/core', 'rxjs/Observable', '@angular/platform-browser'], factory) :
    (factory(global.ng.core,(global.ng = global.ng || {}, global.ng.http = global.ng.http || {}),global.ng.core,global.Rx,global.ng.platformBrowser));
}(this, function (ɵngcc0,exports,_angular_core,rxjs_Observable,_angular_platformBrowser) { 'use strict';

    /**
     * A backend for http that uses the `XMLHttpRequest` browser API.
     *
     * Take care not to evaluate this in non-browser contexts.
     *
     * \@experimental
     */
    var BrowserXhr = (function () {
        function BrowserXhr() {
        }
        /**
         * @return {?}
         */
        BrowserXhr.prototype.build = function () { return ((new XMLHttpRequest())); };
        /** @nocollapse */
        BrowserXhr.ctorParameters = function () { return []; };
BrowserXhr.ɵfac = function BrowserXhr_Factory(t) { return new (t || BrowserXhr)(); };
BrowserXhr.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: BrowserXhr, factory: function (t) { return BrowserXhr.ɵfac(t); } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(BrowserXhr, [{
        type: _angular_core.Injectable
    }], function () { return []; }, null); })();
        return BrowserXhr;
    }());

    var RequestMethod = {};
    RequestMethod.Get = 0;
    RequestMethod.Post = 1;
    RequestMethod.Put = 2;
    RequestMethod.Delete = 3;
    RequestMethod.Options = 4;
    RequestMethod.Head = 5;
    RequestMethod.Patch = 6;
    RequestMethod[RequestMethod.Get] = "Get";
    RequestMethod[RequestMethod.Post] = "Post";
    RequestMethod[RequestMethod.Put] = "Put";
    RequestMethod[RequestMethod.Delete] = "Delete";
    RequestMethod[RequestMethod.Options] = "Options";
    RequestMethod[RequestMethod.Head] = "Head";
    RequestMethod[RequestMethod.Patch] = "Patch";
    var ReadyState = {};
    ReadyState.Unsent = 0;
    ReadyState.Open = 1;
    ReadyState.HeadersReceived = 2;
    ReadyState.Loading = 3;
    ReadyState.Done = 4;
    ReadyState.Cancelled = 5;
    ReadyState[ReadyState.Unsent] = "Unsent";
    ReadyState[ReadyState.Open] = "Open";
    ReadyState[ReadyState.HeadersReceived] = "HeadersReceived";
    ReadyState[ReadyState.Loading] = "Loading";
    ReadyState[ReadyState.Done] = "Done";
    ReadyState[ReadyState.Cancelled] = "Cancelled";
    var ResponseType = {};
    ResponseType.Basic = 0;
    ResponseType.Cors = 1;
    ResponseType.Default = 2;
    ResponseType.Error = 3;
    ResponseType.Opaque = 4;
    ResponseType[ResponseType.Basic] = "Basic";
    ResponseType[ResponseType.Cors] = "Cors";
    ResponseType[ResponseType.Default] = "Default";
    ResponseType[ResponseType.Error] = "Error";
    ResponseType[ResponseType.Opaque] = "Opaque";
    var ContentType = {};
    ContentType.NONE = 0;
    ContentType.JSON = 1;
    ContentType.FORM = 2;
    ContentType.FORM_DATA = 3;
    ContentType.TEXT = 4;
    ContentType.BLOB = 5;
    ContentType.ARRAY_BUFFER = 6;
    ContentType[ContentType.NONE] = "NONE";
    ContentType[ContentType.JSON] = "JSON";
    ContentType[ContentType.FORM] = "FORM";
    ContentType[ContentType.FORM_DATA] = "FORM_DATA";
    ContentType[ContentType.TEXT] = "TEXT";
    ContentType[ContentType.BLOB] = "BLOB";
    ContentType[ContentType.ARRAY_BUFFER] = "ARRAY_BUFFER";
    var ResponseContentType = {};
    ResponseContentType.Text = 0;
    ResponseContentType.Json = 1;
    ResponseContentType.ArrayBuffer = 2;
    ResponseContentType.Blob = 3;
    ResponseContentType[ResponseContentType.Text] = "Text";
    ResponseContentType[ResponseContentType.Json] = "Json";
    ResponseContentType[ResponseContentType.ArrayBuffer] = "ArrayBuffer";
    ResponseContentType[ResponseContentType.Blob] = "Blob";

    /**
     * Polyfill for [Headers](https://developer.mozilla.org/en-US/docs/Web/API/Headers/Headers), as
     * specified in the [Fetch Spec](https://fetch.spec.whatwg.org/#headers-class).
     *
     * The only known difference between this `Headers` implementation and the spec is the
     * lack of an `entries` method.
     *
     * ### Example
     *
     * ```
     * import {Headers} from '\@angular/http';
     *
     * var firstHeaders = new Headers();
     * firstHeaders.append('Content-Type', 'image/jpeg');
     * console.log(firstHeaders.get('Content-Type')) //'image/jpeg'
     *
     * // Create headers from Plain Old JavaScript Object
     * var secondHeaders = new Headers({
     *   'X-My-Custom-Header': 'Angular'
     * });
     * console.log(secondHeaders.get('X-My-Custom-Header')); //'Angular'
     *
     * var thirdHeaders = new Headers(secondHeaders);
     * console.log(thirdHeaders.get('X-My-Custom-Header')); //'Angular'
     * ```
     *
     * \@experimental
     */
    var Headers = (function () {
        /**
         * @param {?=} headers
         */
        function Headers(headers) {
            var _this = this;
            /** @internal header names are lower case */
            this._headers = new Map();
            /** @internal map lower case names to actual names */
            this._normalizedNames = new Map();
            if (!headers) {
                return;
            }
            if (headers instanceof Headers) {
                headers.forEach(function (values, name) {
                    values.forEach(function (value) { return _this.append(name, value); });
                });
                return;
            }
            Object.keys(headers).forEach(function (name) {
                var values = Array.isArray(headers[name]) ? headers[name] : [headers[name]];
                _this.delete(name);
                values.forEach(function (value) { return _this.append(name, value); });
            });
        }
        /**
         * Returns a new Headers instance from the given DOMString of Response Headers
         * @param {?} headersString
         * @return {?}
         */
        Headers.fromResponseHeaderString = function (headersString) {
            var /** @type {?} */ headers = new Headers();
            headersString.split('\n').forEach(function (line) {
                var /** @type {?} */ index = line.indexOf(':');
                if (index > 0) {
                    var /** @type {?} */ name_1 = line.slice(0, index);
                    var /** @type {?} */ value = line.slice(index + 1).trim();
                    headers.set(name_1, value);
                }
            });
            return headers;
        };
        /**
         * Appends a header to existing list of header values for a given header name.
         * @param {?} name
         * @param {?} value
         * @return {?}
         */
        Headers.prototype.append = function (name, value) {
            var /** @type {?} */ values = this.getAll(name);
            if (values === null) {
                this.set(name, value);
            }
            else {
                values.push(value);
            }
        };
        /**
         * Deletes all header values for the given name.
         * @param {?} name
         * @return {?}
         */
        Headers.prototype.delete = function (name) {
            var /** @type {?} */ lcName = name.toLowerCase();
            this._normalizedNames.delete(lcName);
            this._headers.delete(lcName);
        };
        /**
         * @param {?} fn
         * @return {?}
         */
        Headers.prototype.forEach = function (fn) {
            var _this = this;
            this._headers.forEach(function (values, lcName) { return fn(values, _this._normalizedNames.get(lcName), _this._headers); });
        };
        /**
         * Returns first header that matches given name.
         * @param {?} name
         * @return {?}
         */
        Headers.prototype.get = function (name) {
            var /** @type {?} */ values = this.getAll(name);
            if (values === null) {
                return null;
            }
            return values.length > 0 ? values[0] : null;
        };
        /**
         * Checks for existence of header by given name.
         * @param {?} name
         * @return {?}
         */
        Headers.prototype.has = function (name) { return this._headers.has(name.toLowerCase()); };
        /**
         * Returns the names of the headers
         * @return {?}
         */
        Headers.prototype.keys = function () { return Array.from(this._normalizedNames.values()); };
        /**
         * Sets or overrides header value for given name.
         * @param {?} name
         * @param {?} value
         * @return {?}
         */
        Headers.prototype.set = function (name, value) {
            if (Array.isArray(value)) {
                if (value.length) {
                    this._headers.set(name.toLowerCase(), [value.join(',')]);
                }
            }
            else {
                this._headers.set(name.toLowerCase(), [value]);
            }
            this.mayBeSetNormalizedName(name);
        };
        /**
         * Returns values of all headers.
         * @return {?}
         */
        Headers.prototype.values = function () { return Array.from(this._headers.values()); };
        /**
         * @return {?}
         */
        Headers.prototype.toJSON = function () {
            var _this = this;
            var /** @type {?} */ serialized = {};
            this._headers.forEach(function (values, name) {
                var /** @type {?} */ split = [];
                values.forEach(function (v) { return split.push.apply(split, v.split(',')); });
                serialized[_this._normalizedNames.get(name)] = split;
            });
            return serialized;
        };
        /**
         * Returns list of header values for a given name.
         * @param {?} name
         * @return {?}
         */
        Headers.prototype.getAll = function (name) {
            return this.has(name) ? this._headers.get(name.toLowerCase()) : null;
        };
        /**
         * This method is not implemented.
         * @return {?}
         */
        Headers.prototype.entries = function () { throw new Error('"entries" method is not implemented on Headers class'); };
        /**
         * @param {?} name
         * @return {?}
         */
        Headers.prototype.mayBeSetNormalizedName = function (name) {
            var /** @type {?} */ lcName = name.toLowerCase();
            if (!this._normalizedNames.has(lcName)) {
                this._normalizedNames.set(lcName, name);
            }
        };
        return Headers;
    }());

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    var __extends$1 = (this && this.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
    /**
     * Creates a response options object to be optionally provided when instantiating a
     * {\@link Response}.
     *
     * This class is based on the `ResponseInit` description in the [Fetch
     * Spec](https://fetch.spec.whatwg.org/#responseinit).
     *
     * All values are null by default. Typical defaults can be found in the
     * {\@link BaseResponseOptions} class, which sub-classes `ResponseOptions`.
     *
     * This class may be used in tests to build {\@link Response Responses} for
     * mock responses (see {\@link MockBackend}).
     *
     * ### Example ([live demo](http://plnkr.co/edit/P9Jkk8e8cz6NVzbcxEsD?p=preview))
     *
     * ```typescript
     * import {ResponseOptions, Response} from '\@angular/http';
     *
     * var options = new ResponseOptions({
     *   body: '{"name":"Jeff"}'
     * });
     * var res = new Response(options);
     *
     * console.log('res.json():', res.json()); // Object {name: "Jeff"}
     * ```
     *
     * \@experimental
     */
    var ResponseOptions = (function () {
        /**
         * @param {?=} __0
         */
        function ResponseOptions(_a) {
            var _b = _a === void 0 ? {} : _a, body = _b.body, status = _b.status, headers = _b.headers, statusText = _b.statusText, type = _b.type, url = _b.url;
            this.body = body != null ? body : null;
            this.status = status != null ? status : null;
            this.headers = headers != null ? headers : null;
            this.statusText = statusText != null ? statusText : null;
            this.type = type != null ? type : null;
            this.url = url != null ? url : null;
        }
        /**
         * Creates a copy of the `ResponseOptions` instance, using the optional input as values to
         * override
         * existing values. This method will not change the values of the instance on which it is being
         * called.
         *
         * This may be useful when sharing a base `ResponseOptions` object inside tests,
         * where certain properties may change from test to test.
         *
         * ### Example ([live demo](http://plnkr.co/edit/1lXquqFfgduTFBWjNoRE?p=preview))
         *
         * ```typescript
         * import {ResponseOptions, Response} from '\@angular/http';
         *
         * var options = new ResponseOptions({
         *   body: {name: 'Jeff'}
         * });
         * var res = new Response(options.merge({
         *   url: 'https://google.com'
         * }));
         * console.log('options.url:', options.url); // null
         * console.log('res.json():', res.json()); // Object {name: "Jeff"}
         * console.log('res.url:', res.url); // https://google.com
         * ```
         * @param {?=} options
         * @return {?}
         */
        ResponseOptions.prototype.merge = function (options) {
            return new ResponseOptions({
                body: options && options.body != null ? options.body : this.body,
                status: options && options.status != null ? options.status : this.status,
                headers: options && options.headers != null ? options.headers : this.headers,
                statusText: options && options.statusText != null ? options.statusText : this.statusText,
                type: options && options.type != null ? options.type : this.type,
                url: options && options.url != null ? options.url : this.url,
            });
        };
        return ResponseOptions;
    }());
    /**
     * Subclass of {\@link ResponseOptions}, with default values.
     *
     * Default values:
     *  * status: 200
     *  * headers: empty {\@link Headers} object
     *
     * This class could be extended and bound to the {\@link ResponseOptions} class
     * when configuring an {\@link Injector}, in order to override the default options
     * used by {\@link Http} to create {\@link Response Responses}.
     *
     * ### Example ([live demo](http://plnkr.co/edit/qv8DLT?p=preview))
     *
     * ```typescript
     * import {provide} from '\@angular/core';
     * import {bootstrap} from '\@angular/platform-browser/browser';
     * import {HTTP_PROVIDERS, Headers, Http, BaseResponseOptions, ResponseOptions} from
     * '\@angular/http';
     * import {App} from './myapp';
     *
     * class MyOptions extends BaseResponseOptions {
     *   headers:Headers = new Headers({network: 'github'});
     * }
     *
     * bootstrap(App, [HTTP_PROVIDERS, {provide: ResponseOptions, useClass: MyOptions}]);
     * ```
     *
     * The options could also be extended when manually creating a {\@link Response}
     * object.
     *
     * ### Example ([live demo](http://plnkr.co/edit/VngosOWiaExEtbstDoix?p=preview))
     *
     * ```
     * import {BaseResponseOptions, Response} from '\@angular/http';
     *
     * var options = new BaseResponseOptions();
     * var res = new Response(options.merge({
     *   body: 'Angular',
     *   headers: new Headers({framework: 'angular'})
     * }));
     * console.log('res.headers.get("framework"):', res.headers.get('framework')); // angular
     * console.log('res.text():', res.text()); // Angular;
     * ```
     *
     * \@experimental
     */
    var BaseResponseOptions = (function (_super) {
        __extends$1(BaseResponseOptions, _super);
        function BaseResponseOptions() {
            _super.call(this, { status: 200, statusText: 'Ok', type: ResponseType.Default, headers: new Headers() });
        }
        /** @nocollapse */
        BaseResponseOptions.ctorParameters = function () { return []; };
BaseResponseOptions.ɵfac = function BaseResponseOptions_Factory(t) { return new (t || BaseResponseOptions)(); };
BaseResponseOptions.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: BaseResponseOptions, factory: function (t) { return BaseResponseOptions.ɵfac(t); } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(BaseResponseOptions, [{
        type: _angular_core.Injectable
    }], function () { return []; }, null); })();
        return BaseResponseOptions;
    }(ResponseOptions));

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Abstract class from which real backends are derived.
     *
     * The primary purpose of a `ConnectionBackend` is to create new connections to fulfill a given
     * {\@link Request}.
     *
     * \@experimental
     * @abstract
     */
    var ConnectionBackend = (function () {
        function ConnectionBackend() {
        }
        /**
         * @abstract
         * @param {?} request
         * @return {?}
         */
        ConnectionBackend.prototype.createConnection = function (request) { };
        return ConnectionBackend;
    }());
    /**
     * Abstract class from which real connections are derived.
     *
     * \@experimental
     * @abstract
     */
    var Connection = (function () {
        function Connection() {
        }
        return Connection;
    }());
    /**
     * An XSRFStrategy configures XSRF protection (e.g. via headers) on an HTTP request.
     *
     * \@experimental
     * @abstract
     */
    var XSRFStrategy = (function () {
        function XSRFStrategy() {
        }
        /**
         * @abstract
         * @param {?} req
         * @return {?}
         */
        XSRFStrategy.prototype.configureRequest = function (req) { };
        return XSRFStrategy;
    }());

    /**
     * @param {?} method
     * @return {?}
     */
    function normalizeMethodName(method) {
        if (typeof method !== 'string')
            return method;
        switch (method.toUpperCase()) {
            case 'GET':
                return RequestMethod.Get;
            case 'POST':
                return RequestMethod.Post;
            case 'PUT':
                return RequestMethod.Put;
            case 'DELETE':
                return RequestMethod.Delete;
            case 'OPTIONS':
                return RequestMethod.Options;
            case 'HEAD':
                return RequestMethod.Head;
            case 'PATCH':
                return RequestMethod.Patch;
        }
        throw new Error("Invalid request method. The method \"" + method + "\" is not supported.");
    }
    var /** @type {?} */ isSuccess = function (status) { return (status >= 200 && status < 300); };
    /**
     * @param {?} xhr
     * @return {?}
     */
    function getResponseURL(xhr) {
        if ('responseURL' in xhr) {
            return xhr.responseURL;
        }
        if (/^X-Request-URL:/m.test(xhr.getAllResponseHeaders())) {
            return xhr.getResponseHeader('X-Request-URL');
        }
        return;
    }
    /**
     * @param {?} input
     * @return {?}
     */
    function stringToArrayBuffer(input) {
        var /** @type {?} */ view = new Uint16Array(input.length);
        for (var /** @type {?} */ i = 0, /** @type {?} */ strLen = input.length; i < strLen; i++) {
            view[i] = input.charCodeAt(i);
        }
        return view.buffer;
    }

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     * @param {?=} rawParams
     * @return {?}
     */
    function paramParser(rawParams) {
        if (rawParams === void 0) { rawParams = ''; }
        var /** @type {?} */ map = new Map();
        if (rawParams.length > 0) {
            var /** @type {?} */ params = rawParams.split('&');
            params.forEach(function (param) {
                var /** @type {?} */ eqIdx = param.indexOf('=');
                var _a = eqIdx == -1 ? [param, ''] : [param.slice(0, eqIdx), param.slice(eqIdx + 1)], key = _a[0], val = _a[1];
                var /** @type {?} */ list = map.get(key) || [];
                list.push(val);
                map.set(key, list);
            });
        }
        return map;
    }
    /**
     * \@experimental
     *
     */
    var QueryEncoder = (function () {
        function QueryEncoder() {
        }
        /**
         * @param {?} k
         * @return {?}
         */
        QueryEncoder.prototype.encodeKey = function (k) { return standardEncoding(k); };
        /**
         * @param {?} v
         * @return {?}
         */
        QueryEncoder.prototype.encodeValue = function (v) { return standardEncoding(v); };
        return QueryEncoder;
    }());
    /**
     * @param {?} v
     * @return {?}
     */
    function standardEncoding(v) {
        return encodeURIComponent(v)
            .replace(/%40/gi, '@')
            .replace(/%3A/gi, ':')
            .replace(/%24/gi, '$')
            .replace(/%2C/gi, ',')
            .replace(/%3B/gi, ';')
            .replace(/%2B/gi, '+')
            .replace(/%3D/gi, '=')
            .replace(/%3F/gi, '?')
            .replace(/%2F/gi, '/');
    }
    /**
     * Map-like representation of url search parameters, based on
     * [URLSearchParams](https://url.spec.whatwg.org/#urlsearchparams) in the url living standard,
     * with several extensions for merging URLSearchParams objects:
     *   - setAll()
     *   - appendAll()
     *   - replaceAll()
     *
     * This class accepts an optional second parameter of ${\@link QueryEncoder},
     * which is used to serialize parameters before making a request. By default,
     * `QueryEncoder` encodes keys and values of parameters using `encodeURIComponent`,
     * and then un-encodes certain characters that are allowed to be part of the query
     * according to IETF RFC 3986: https://tools.ietf.org/html/rfc3986.
     *
     * These are the characters that are not encoded: `! $ \' ( ) * + , ; A 9 - . _ ~ ? /`
     *
     * If the set of allowed query characters is not acceptable for a particular backend,
     * `QueryEncoder` can be subclassed and provided as the 2nd argument to URLSearchParams.
     *
     * ```
     * import {URLSearchParams, QueryEncoder} from '\@angular/http';
     * class MyQueryEncoder extends QueryEncoder {
     *   encodeKey(k: string): string {
     *     return myEncodingFunction(k);
     *   }
     *
     *   encodeValue(v: string): string {
     *     return myEncodingFunction(v);
     *   }
     * }
     *
     * let params = new URLSearchParams('', new MyQueryEncoder());
     * ```
     * \@experimental
     */
    var URLSearchParams = (function () {
        /**
         * @param {?=} rawParams
         * @param {?=} queryEncoder
         */
        function URLSearchParams(rawParams, queryEncoder) {
            if (rawParams === void 0) { rawParams = ''; }
            if (queryEncoder === void 0) { queryEncoder = new QueryEncoder(); }
            this.rawParams = rawParams;
            this.queryEncoder = queryEncoder;
            this.paramsMap = paramParser(rawParams);
        }
        /**
         * @return {?}
         */
        URLSearchParams.prototype.clone = function () {
            var /** @type {?} */ clone = new URLSearchParams('', this.queryEncoder);
            clone.appendAll(this);
            return clone;
        };
        /**
         * @param {?} param
         * @return {?}
         */
        URLSearchParams.prototype.has = function (param) { return this.paramsMap.has(param); };
        /**
         * @param {?} param
         * @return {?}
         */
        URLSearchParams.prototype.get = function (param) {
            var /** @type {?} */ storedParam = this.paramsMap.get(param);
            return Array.isArray(storedParam) ? storedParam[0] : null;
        };
        /**
         * @param {?} param
         * @return {?}
         */
        URLSearchParams.prototype.getAll = function (param) { return this.paramsMap.get(param) || []; };
        /**
         * @param {?} param
         * @param {?} val
         * @return {?}
         */
        URLSearchParams.prototype.set = function (param, val) {
            if (val === void 0 || val === null) {
                this.delete(param);
                return;
            }
            var /** @type {?} */ list = this.paramsMap.get(param) || [];
            list.length = 0;
            list.push(val);
            this.paramsMap.set(param, list);
        };
        /**
         * @param {?} searchParams
         * @return {?}
         */
        URLSearchParams.prototype.setAll = function (searchParams) {
            var _this = this;
            searchParams.paramsMap.forEach(function (value, param) {
                var /** @type {?} */ list = _this.paramsMap.get(param) || [];
                list.length = 0;
                list.push(value[0]);
                _this.paramsMap.set(param, list);
            });
        };
        /**
         * @param {?} param
         * @param {?} val
         * @return {?}
         */
        URLSearchParams.prototype.append = function (param, val) {
            if (val === void 0 || val === null)
                return;
            var /** @type {?} */ list = this.paramsMap.get(param) || [];
            list.push(val);
            this.paramsMap.set(param, list);
        };
        /**
         * @param {?} searchParams
         * @return {?}
         */
        URLSearchParams.prototype.appendAll = function (searchParams) {
            var _this = this;
            searchParams.paramsMap.forEach(function (value, param) {
                var /** @type {?} */ list = _this.paramsMap.get(param) || [];
                for (var /** @type {?} */ i = 0; i < value.length; ++i) {
                    list.push(value[i]);
                }
                _this.paramsMap.set(param, list);
            });
        };
        /**
         * @param {?} searchParams
         * @return {?}
         */
        URLSearchParams.prototype.replaceAll = function (searchParams) {
            var _this = this;
            searchParams.paramsMap.forEach(function (value, param) {
                var /** @type {?} */ list = _this.paramsMap.get(param) || [];
                list.length = 0;
                for (var /** @type {?} */ i = 0; i < value.length; ++i) {
                    list.push(value[i]);
                }
                _this.paramsMap.set(param, list);
            });
        };
        /**
         * @return {?}
         */
        URLSearchParams.prototype.toString = function () {
            var _this = this;
            var /** @type {?} */ paramsList = [];
            this.paramsMap.forEach(function (values, k) {
                values.forEach(function (v) { return paramsList.push(_this.queryEncoder.encodeKey(k) + '=' + _this.queryEncoder.encodeValue(v)); });
            });
            return paramsList.join('&');
        };
        /**
         * @param {?} param
         * @return {?}
         */
        URLSearchParams.prototype.delete = function (param) { this.paramsMap.delete(param); };
        return URLSearchParams;
    }());

    /**
     * HTTP request body used by both {\@link Request} and {\@link Response}
     * https://fetch.spec.whatwg.org/#body
     * @abstract
     */
    var Body = (function () {
        function Body() {
        }
        /**
         * Attempts to return body as parsed `JSON` object, or raises an exception.
         * @return {?}
         */
        Body.prototype.json = function () {
            if (typeof this._body === 'string') {
                return JSON.parse(/** @type {?} */ (this._body));
            }
            if (this._body instanceof ArrayBuffer) {
                return JSON.parse(this.text());
            }
            return this._body;
        };
        /**
         * Returns the body as a string, presuming `toString()` can be called on the response body.
         * @return {?}
         */
        Body.prototype.text = function () {
            if (this._body instanceof URLSearchParams) {
                return this._body.toString();
            }
            if (this._body instanceof ArrayBuffer) {
                return String.fromCharCode.apply(null, new Uint16Array(/** @type {?} */ (this._body)));
            }
            if (this._body == null) {
                return '';
            }
            if (typeof this._body === 'object') {
                return JSON.stringify(this._body, null, 2);
            }
            return this._body.toString();
        };
        /**
         * Return the body as an ArrayBuffer
         * @return {?}
         */
        Body.prototype.arrayBuffer = function () {
            if (this._body instanceof ArrayBuffer) {
                return (this._body);
            }
            return stringToArrayBuffer(this.text());
        };
        /**
         * Returns the request's body as a Blob, assuming that body exists.
         * @return {?}
         */
        Body.prototype.blob = function () {
            if (this._body instanceof Blob) {
                return (this._body);
            }
            if (this._body instanceof ArrayBuffer) {
                return new Blob([this._body]);
            }
            throw new Error('The request body isn\'t either a blob or an array buffer');
        };
        return Body;
    }());

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    var __extends$2 = (this && this.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
    /**
     * Creates `Response` instances from provided values.
     *
     * Though this object isn't
     * usually instantiated by end-users, it is the primary object interacted with when it comes time to
     * add data to a view.
     *
     * ### Example
     *
     * ```
     * http.request('my-friends.txt').subscribe(response => this.friends = response.text());
     * ```
     *
     * The Response's interface is inspired by the Response constructor defined in the [Fetch
     * Spec](https://fetch.spec.whatwg.org/#response-class), but is considered a static value whose body
     * can be accessed many times. There are other differences in the implementation, but this is the
     * most significant.
     *
     * \@experimental
     */
    var Response = (function (_super) {
        __extends$2(Response, _super);
        /**
         * @param {?} responseOptions
         */
        function Response(responseOptions) {
            _super.call(this);
            this._body = responseOptions.body;
            this.status = responseOptions.status;
            this.ok = (this.status >= 200 && this.status <= 299);
            this.statusText = responseOptions.statusText;
            this.headers = responseOptions.headers;
            this.type = responseOptions.type;
            this.url = responseOptions.url;
        }
        /**
         * @return {?}
         */
        Response.prototype.toString = function () {
            return "Response with status: " + this.status + " " + this.statusText + " for URL: " + this.url;
        };
        return Response;
    }(Body));

    var /** @type {?} */ _nextRequestId = 0;
    var /** @type {?} */ JSONP_HOME = '__ng_jsonp__';
    var /** @type {?} */ _jsonpConnections = null;
    /**
     * @return {?}
     */
    function _getJsonpConnections() {
        var /** @type {?} */ w = typeof window == 'object' ? window : {};
        if (_jsonpConnections === null) {
            _jsonpConnections = w[JSONP_HOME] = {};
        }
        return _jsonpConnections;
    }
    var BrowserJsonp = (function () {
        function BrowserJsonp() {
        }
        /**
         * @param {?} url
         * @return {?}
         */
        BrowserJsonp.prototype.build = function (url) {
            var /** @type {?} */ node = document.createElement('script');
            node.src = url;
            return node;
        };
        /**
         * @return {?}
         */
        BrowserJsonp.prototype.nextRequestID = function () { return "__req" + _nextRequestId++; };
        /**
         * @param {?} id
         * @return {?}
         */
        BrowserJsonp.prototype.requestCallback = function (id) { return JSONP_HOME + "." + id + ".finished"; };
        /**
         * @param {?} id
         * @param {?} connection
         * @return {?}
         */
        BrowserJsonp.prototype.exposeConnection = function (id, connection) {
            var /** @type {?} */ connections = _getJsonpConnections();
            connections[id] = connection;
        };
        /**
         * @param {?} id
         * @return {?}
         */
        BrowserJsonp.prototype.removeConnection = function (id) {
            var /** @type {?} */ connections = _getJsonpConnections();
            connections[id] = null;
        };
        /**
         * @param {?} node
         * @return {?}
         */
        BrowserJsonp.prototype.send = function (node) { document.body.appendChild(/** @type {?} */ ((node))); };
        /**
         * @param {?} node
         * @return {?}
         */
        BrowserJsonp.prototype.cleanup = function (node) {
            if (node.parentNode) {
                node.parentNode.removeChild(/** @type {?} */ ((node)));
            }
        };
        /** @nocollapse */
        BrowserJsonp.ctorParameters = function () { return []; };
BrowserJsonp.ɵfac = function BrowserJsonp_Factory(t) { return new (t || BrowserJsonp)(); };
BrowserJsonp.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: BrowserJsonp, factory: function (t) { return BrowserJsonp.ɵfac(t); } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(BrowserJsonp, [{
        type: _angular_core.Injectable
    }], function () { return []; }, null); })();
        return BrowserJsonp;
    }());

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    var __extends = (this && this.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
    var /** @type {?} */ JSONP_ERR_NO_CALLBACK = 'JSONP injected script did not invoke callback.';
    var /** @type {?} */ JSONP_ERR_WRONG_METHOD = 'JSONP requests must use GET request method.';
    /**
     * Abstract base class for an in-flight JSONP request.
     *
     * \@experimental
     * @abstract
     */
    var JSONPConnection = (function () {
        function JSONPConnection() {
        }
        /**
         * Callback called when the JSONP request completes, to notify the application
         * of the new data.
         * @abstract
         * @param {?=} data
         * @return {?}
         */
        JSONPConnection.prototype.finished = function (data) { };
        return JSONPConnection;
    }());
    var JSONPConnection_ = (function (_super) {
        __extends(JSONPConnection_, _super);
        /**
         * @param {?} req
         * @param {?} _dom
         * @param {?=} baseResponseOptions
         */
        function JSONPConnection_(req, _dom, baseResponseOptions) {
            var _this = this;
            _super.call(this);
            this._dom = _dom;
            this.baseResponseOptions = baseResponseOptions;
            this._finished = false;
            if (req.method !== RequestMethod.Get) {
                throw new TypeError(JSONP_ERR_WRONG_METHOD);
            }
            this.request = req;
            this.response = new rxjs_Observable.Observable(function (responseObserver) {
                _this.readyState = ReadyState.Loading;
                var id = _this._id = _dom.nextRequestID();
                _dom.exposeConnection(id, _this);
                // Workaround Dart
                // url = url.replace(/=JSONP_CALLBACK(&|$)/, `generated method`);
                var callback = _dom.requestCallback(_this._id);
                var url = req.url;
                if (url.indexOf('=JSONP_CALLBACK&') > -1) {
                    url = url.replace('=JSONP_CALLBACK&', "=" + callback + "&");
                }
                else if (url.lastIndexOf('=JSONP_CALLBACK') === url.length - '=JSONP_CALLBACK'.length) {
                    url = url.substring(0, url.length - '=JSONP_CALLBACK'.length) + ("=" + callback);
                }
                var script = _this._script = _dom.build(url);
                var onLoad = function (event) {
                    if (_this.readyState === ReadyState.Cancelled)
                        return;
                    _this.readyState = ReadyState.Done;
                    _dom.cleanup(script);
                    if (!_this._finished) {
                        var responseOptions_1 = new ResponseOptions({ body: JSONP_ERR_NO_CALLBACK, type: ResponseType.Error, url: url });
                        if (baseResponseOptions) {
                            responseOptions_1 = baseResponseOptions.merge(responseOptions_1);
                        }
                        responseObserver.error(new Response(responseOptions_1));
                        return;
                    }
                    var responseOptions = new ResponseOptions({ body: _this._responseData, url: url });
                    if (_this.baseResponseOptions) {
                        responseOptions = _this.baseResponseOptions.merge(responseOptions);
                    }
                    responseObserver.next(new Response(responseOptions));
                    responseObserver.complete();
                };
                var onError = function (error) {
                    if (_this.readyState === ReadyState.Cancelled)
                        return;
                    _this.readyState = ReadyState.Done;
                    _dom.cleanup(script);
                    var responseOptions = new ResponseOptions({ body: error.message, type: ResponseType.Error });
                    if (baseResponseOptions) {
                        responseOptions = baseResponseOptions.merge(responseOptions);
                    }
                    responseObserver.error(new Response(responseOptions));
                };
                script.addEventListener('load', onLoad);
                script.addEventListener('error', onError);
                _dom.send(script);
                return function () {
                    _this.readyState = ReadyState.Cancelled;
                    script.removeEventListener('load', onLoad);
                    script.removeEventListener('error', onError);
                    _this._dom.cleanup(script);
                };
            });
        }
        /**
         * @param {?=} data
         * @return {?}
         */
        JSONPConnection_.prototype.finished = function (data) {
            // Don't leak connections
            this._finished = true;
            this._dom.removeConnection(this._id);
            if (this.readyState === ReadyState.Cancelled)
                return;
            this._responseData = data;
        };
        return JSONPConnection_;
    }(JSONPConnection));
    /**
     * A {\@link ConnectionBackend} that uses the JSONP strategy of making requests.
     *
     * \@experimental
     * @abstract
     */
    var JSONPBackend = (function (_super) {
        __extends(JSONPBackend, _super);
        function JSONPBackend() {
            _super.apply(this, arguments);
        }
        return JSONPBackend;
    }(ConnectionBackend));
    var JSONPBackend_ = (function (_super) {
        __extends(JSONPBackend_, _super);
        /**
         * @param {?} _browserJSONP
         * @param {?} _baseResponseOptions
         */
        function JSONPBackend_(_browserJSONP, _baseResponseOptions) {
            _super.call(this);
            this._browserJSONP = _browserJSONP;
            this._baseResponseOptions = _baseResponseOptions;
        }
        /**
         * @param {?} request
         * @return {?}
         */
        JSONPBackend_.prototype.createConnection = function (request) {
            return new JSONPConnection_(request, this._browserJSONP, this._baseResponseOptions);
        };
        /** @nocollapse */
        JSONPBackend_.ctorParameters = function () { return [
            { type: BrowserJsonp, },
            { type: ResponseOptions, },
        ]; };
JSONPBackend_.ɵfac = function JSONPBackend__Factory(t) { return new (t || JSONPBackend_)(ɵngcc0.ɵɵinject(BrowserJsonp), ɵngcc0.ɵɵinject(ResponseOptions)); };
JSONPBackend_.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: JSONPBackend_, factory: function (t) { return JSONPBackend_.ɵfac(t); } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(JSONPBackend_, [{
        type: _angular_core.Injectable
    }], function () { return [{ type: BrowserJsonp }, { type: ResponseOptions }]; }, null); })();
        return JSONPBackend_;
    }(JSONPBackend));

    var /** @type {?} */ XSSI_PREFIX = /^\)\]\}',?\n/;
    /**
     * Creates connections using `XMLHttpRequest`. Given a fully-qualified
     * request, an `XHRConnection` will immediately create an `XMLHttpRequest` object and send the
     * request.
     *
     * This class would typically not be created or interacted with directly inside applications, though
     * the {\@link MockConnection} may be interacted with in tests.
     *
     * \@experimental
     */
    var XHRConnection = (function () {
        /**
         * @param {?} req
         * @param {?} browserXHR
         * @param {?=} baseResponseOptions
         */
        function XHRConnection(req, browserXHR, baseResponseOptions) {
            var _this = this;
            this.request = req;
            this.response = new rxjs_Observable.Observable(function (responseObserver) {
                var _xhr = browserXHR.build();
                _xhr.open(RequestMethod[req.method].toUpperCase(), req.url);
                if (req.withCredentials != null) {
                    _xhr.withCredentials = req.withCredentials;
                }
                // load event handler
                var onLoad = function () {
                    // normalize IE9 bug (http://bugs.jquery.com/ticket/1450)
                    var status = _xhr.status === 1223 ? 204 : _xhr.status;
                    var body = null;
                    // HTTP 204 means no content
                    if (status !== 204) {
                        // responseText is the old-school way of retrieving response (supported by IE8 & 9)
                        // response/responseType properties were introduced in ResourceLoader Level2 spec
                        // (supported by IE10)
                        body = (typeof _xhr.response === 'undefined') ? _xhr.responseText : _xhr.response;
                        // Implicitly strip a potential XSSI prefix.
                        if (typeof body === 'string') {
                            body = body.replace(XSSI_PREFIX, '');
                        }
                    }
                    // fix status code when it is 0 (0 status is undocumented).
                    // Occurs when accessing file resources or on Android 4.1 stock browser
                    // while retrieving files from application cache.
                    if (status === 0) {
                        status = body ? 200 : 0;
                    }
                    var headers = Headers.fromResponseHeaderString(_xhr.getAllResponseHeaders());
                    // IE 9 does not provide the way to get URL of response
                    var url = getResponseURL(_xhr) || req.url;
                    var statusText = _xhr.statusText || 'OK';
                    var responseOptions = new ResponseOptions({ body: body, status: status, headers: headers, statusText: statusText, url: url });
                    if (baseResponseOptions != null) {
                        responseOptions = baseResponseOptions.merge(responseOptions);
                    }
                    var response = new Response(responseOptions);
                    response.ok = isSuccess(status);
                    if (response.ok) {
                        responseObserver.next(response);
                        // TODO(gdi2290): defer complete if array buffer until done
                        responseObserver.complete();
                        return;
                    }
                    responseObserver.error(response);
                };
                // error event handler
                var onError = function (err) {
                    var responseOptions = new ResponseOptions({
                        body: err,
                        type: ResponseType.Error,
                        status: _xhr.status,
                        statusText: _xhr.statusText,
                    });
                    if (baseResponseOptions != null) {
                        responseOptions = baseResponseOptions.merge(responseOptions);
                    }
                    responseObserver.error(new Response(responseOptions));
                };
                _this.setDetectedContentType(req, _xhr);
                if (req.headers == null) {
                    req.headers = new Headers();
                }
                if (!req.headers.has('Accept')) {
                    req.headers.append('Accept', 'application/json, text/plain, */*');
                }
                req.headers.forEach(function (values, name) { return _xhr.setRequestHeader(name, values.join(',')); });
                // Select the correct buffer type to store the response
                if (req.responseType != null && _xhr.responseType != null) {
                    switch (req.responseType) {
                        case ResponseContentType.ArrayBuffer:
                            _xhr.responseType = 'arraybuffer';
                            break;
                        case ResponseContentType.Json:
                            _xhr.responseType = 'json';
                            break;
                        case ResponseContentType.Text:
                            _xhr.responseType = 'text';
                            break;
                        case ResponseContentType.Blob:
                            _xhr.responseType = 'blob';
                            break;
                        default:
                            throw new Error('The selected responseType is not supported');
                    }
                }
                _xhr.addEventListener('load', onLoad);
                _xhr.addEventListener('error', onError);
                _xhr.send(_this.request.getBody());
                return function () {
                    _xhr.removeEventListener('load', onLoad);
                    _xhr.removeEventListener('error', onError);
                    _xhr.abort();
                };
            });
        }
        /**
         * @param {?} req
         * @param {?} _xhr
         * @return {?}
         */
        XHRConnection.prototype.setDetectedContentType = function (req /** TODO Request */, _xhr /** XMLHttpRequest */) {
            // Skip if a custom Content-Type header is provided
            if (req.headers != null && req.headers.get('Content-Type') != null) {
                return;
            }
            // Set the detected content type
            switch (req.contentType) {
                case ContentType.NONE:
                    break;
                case ContentType.JSON:
                    _xhr.setRequestHeader('content-type', 'application/json');
                    break;
                case ContentType.FORM:
                    _xhr.setRequestHeader('content-type', 'application/x-www-form-urlencoded;charset=UTF-8');
                    break;
                case ContentType.TEXT:
                    _xhr.setRequestHeader('content-type', 'text/plain');
                    break;
                case ContentType.BLOB:
                    var /** @type {?} */ blob = req.blob();
                    if (blob.type) {
                        _xhr.setRequestHeader('content-type', blob.type);
                    }
                    break;
            }
        };
        return XHRConnection;
    }());
    /**
     * `XSRFConfiguration` sets up Cross Site Request Forgery (XSRF) protection for the application
     * using a cookie. See https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)
     * for more information on XSRF.
     *
     * Applications can configure custom cookie and header names by binding an instance of this class
     * with different `cookieName` and `headerName` values. See the main HTTP documentation for more
     * details.
     *
     * \@experimental
     */
    var CookieXSRFStrategy = (function () {
        /**
         * @param {?=} _cookieName
         * @param {?=} _headerName
         */
        function CookieXSRFStrategy(_cookieName, _headerName) {
            if (_cookieName === void 0) { _cookieName = 'XSRF-TOKEN'; }
            if (_headerName === void 0) { _headerName = 'X-XSRF-TOKEN'; }
            this._cookieName = _cookieName;
            this._headerName = _headerName;
        }
        /**
         * @param {?} req
         * @return {?}
         */
        CookieXSRFStrategy.prototype.configureRequest = function (req) {
            var /** @type {?} */ xsrfToken = _angular_platformBrowser.__platform_browser_private__.getDOM().getCookie(this._cookieName);
            if (xsrfToken) {
                req.headers.set(this._headerName, xsrfToken);
            }
        };
        return CookieXSRFStrategy;
    }());
    /**
     * Creates {\@link XHRConnection} instances.
     *
     * This class would typically not be used by end users, but could be
     * overridden if a different backend implementation should be used,
     * such as in a node backend.
     *
     * ### Example
     *
     * ```
     * import {Http, MyNodeBackend, HTTP_PROVIDERS, BaseRequestOptions} from '\@angular/http';
     * \@Component({
     *   viewProviders: [
     *     HTTP_PROVIDERS,
     *     {provide: Http, useFactory: (backend, options) => {
     *       return new Http(backend, options);
     *     }, deps: [MyNodeBackend, BaseRequestOptions]}]
     * })
     * class MyComponent {
     *   constructor(http:Http) {
     *     http.request('people.json').subscribe(res => this.people = res.json());
     *   }
     * }
     * ```
     * \@experimental
     */
    var XHRBackend = (function () {
        /**
         * @param {?} _browserXHR
         * @param {?} _baseResponseOptions
         * @param {?} _xsrfStrategy
         */
        function XHRBackend(_browserXHR, _baseResponseOptions, _xsrfStrategy) {
            this._browserXHR = _browserXHR;
            this._baseResponseOptions = _baseResponseOptions;
            this._xsrfStrategy = _xsrfStrategy;
        }
        /**
         * @param {?} request
         * @return {?}
         */
        XHRBackend.prototype.createConnection = function (request) {
            this._xsrfStrategy.configureRequest(request);
            return new XHRConnection(request, this._browserXHR, this._baseResponseOptions);
        };
        /** @nocollapse */
        XHRBackend.ctorParameters = function () { return [
            { type: BrowserXhr, },
            { type: ResponseOptions, },
            { type: XSRFStrategy, },
        ]; };
XHRBackend.ɵfac = function XHRBackend_Factory(t) { return new (t || XHRBackend)(ɵngcc0.ɵɵinject(BrowserXhr), ɵngcc0.ɵɵinject(ResponseOptions), ɵngcc0.ɵɵinject(XSRFStrategy)); };
XHRBackend.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: XHRBackend, factory: function (t) { return XHRBackend.ɵfac(t); } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(XHRBackend, [{
        type: _angular_core.Injectable
    }], function () { return [{ type: BrowserXhr }, { type: ResponseOptions }, { type: XSRFStrategy }]; }, null); })();
        return XHRBackend;
    }());

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    var __extends$3 = (this && this.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
    /**
     * Creates a request options object to be optionally provided when instantiating a
     * {\@link Request}.
     *
     * This class is based on the `RequestInit` description in the [Fetch
     * Spec](https://fetch.spec.whatwg.org/#requestinit).
     *
     * All values are null by default. Typical defaults can be found in the {\@link BaseRequestOptions}
     * class, which sub-classes `RequestOptions`.
     *
     * ### Example ([live demo](http://plnkr.co/edit/7Wvi3lfLq41aQPKlxB4O?p=preview))
     *
     * ```typescript
     * import {RequestOptions, Request, RequestMethod} from '\@angular/http';
     *
     * var options = new RequestOptions({
     *   method: RequestMethod.Post,
     *   url: 'https://google.com'
     * });
     * var req = new Request(options);
     * console.log('req.method:', RequestMethod[req.method]); // Post
     * console.log('options.url:', options.url); // https://google.com
     * ```
     *
     * \@experimental
     */
    var RequestOptions = (function () {
        /**
         * @param {?=} __0
         */
        function RequestOptions(_a) {
            var _b = _a === void 0 ? {} : _a, method = _b.method, headers = _b.headers, body = _b.body, url = _b.url, search = _b.search, withCredentials = _b.withCredentials, responseType = _b.responseType;
            this.method = method != null ? normalizeMethodName(method) : null;
            this.headers = headers != null ? headers : null;
            this.body = body != null ? body : null;
            this.url = url != null ? url : null;
            this.search =
                search != null ? (typeof search === 'string' ? new URLSearchParams(search) : search) : null;
            this.withCredentials = withCredentials != null ? withCredentials : null;
            this.responseType = responseType != null ? responseType : null;
        }
        /**
         * Creates a copy of the `RequestOptions` instance, using the optional input as values to override
         * existing values. This method will not change the values of the instance on which it is being
         * called.
         *
         * Note that `headers` and `search` will override existing values completely if present in
         * the `options` object. If these values should be merged, it should be done prior to calling
         * `merge` on the `RequestOptions` instance.
         *
         * ### Example ([live demo](http://plnkr.co/edit/6w8XA8YTkDRcPYpdB9dk?p=preview))
         *
         * ```typescript
         * import {RequestOptions, Request, RequestMethod} from '\@angular/http';
         *
         * var options = new RequestOptions({
         *   method: RequestMethod.Post
         * });
         * var req = new Request(options.merge({
         *   url: 'https://google.com'
         * }));
         * console.log('req.method:', RequestMethod[req.method]); // Post
         * console.log('options.url:', options.url); // null
         * console.log('req.url:', req.url); // https://google.com
         * ```
         * @param {?=} options
         * @return {?}
         */
        RequestOptions.prototype.merge = function (options) {
            return new RequestOptions({
                method: options && options.method != null ? options.method : this.method,
                headers: options && options.headers != null ? options.headers : new Headers(this.headers),
                body: options && options.body != null ? options.body : this.body,
                url: options && options.url != null ? options.url : this.url,
                search: options && options.search != null ?
                    (typeof options.search === 'string' ? new URLSearchParams(options.search) :
                        options.search.clone()) :
                    this.search,
                withCredentials: options && options.withCredentials != null ? options.withCredentials :
                    this.withCredentials,
                responseType: options && options.responseType != null ? options.responseType :
                    this.responseType
            });
        };
        return RequestOptions;
    }());
    /**
     * Subclass of {\@link RequestOptions}, with default values.
     *
     * Default values:
     *  * method: {\@link RequestMethod RequestMethod.Get}
     *  * headers: empty {\@link Headers} object
     *
     * This class could be extended and bound to the {\@link RequestOptions} class
     * when configuring an {\@link Injector}, in order to override the default options
     * used by {\@link Http} to create and send {\@link Request Requests}.
     *
     * ### Example ([live demo](http://plnkr.co/edit/LEKVSx?p=preview))
     *
     * ```typescript
     * import {provide} from '\@angular/core';
     * import {bootstrap} from '\@angular/platform-browser/browser';
     * import {HTTP_PROVIDERS, Http, BaseRequestOptions, RequestOptions} from '\@angular/http';
     * import {App} from './myapp';
     *
     * class MyOptions extends BaseRequestOptions {
     *   search: string = 'coreTeam=true';
     * }
     *
     * bootstrap(App, [HTTP_PROVIDERS, {provide: RequestOptions, useClass: MyOptions}]);
     * ```
     *
     * The options could also be extended when manually creating a {\@link Request}
     * object.
     *
     * ### Example ([live demo](http://plnkr.co/edit/oyBoEvNtDhOSfi9YxaVb?p=preview))
     *
     * ```
     * import {BaseRequestOptions, Request, RequestMethod} from '\@angular/http';
     *
     * var options = new BaseRequestOptions();
     * var req = new Request(options.merge({
     *   method: RequestMethod.Post,
     *   url: 'https://google.com'
     * }));
     * console.log('req.method:', RequestMethod[req.method]); // Post
     * console.log('options.url:', options.url); // null
     * console.log('req.url:', req.url); // https://google.com
     * ```
     *
     * \@experimental
     */
    var BaseRequestOptions = (function (_super) {
        __extends$3(BaseRequestOptions, _super);
        function BaseRequestOptions() {
            _super.call(this, { method: RequestMethod.Get, headers: new Headers() });
        }
        /** @nocollapse */
        BaseRequestOptions.ctorParameters = function () { return []; };
BaseRequestOptions.ɵfac = function BaseRequestOptions_Factory(t) { return new (t || BaseRequestOptions)(); };
BaseRequestOptions.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: BaseRequestOptions, factory: function (t) { return BaseRequestOptions.ɵfac(t); } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(BaseRequestOptions, [{
        type: _angular_core.Injectable
    }], function () { return []; }, null); })();
        return BaseRequestOptions;
    }(RequestOptions));

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    var __extends$5 = (this && this.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
    /**
     * Creates `Request` instances from provided values.
     *
     * The Request's interface is inspired by the Request constructor defined in the [Fetch
     * Spec](https://fetch.spec.whatwg.org/#request-class),
     * but is considered a static value whose body can be accessed many times. There are other
     * differences in the implementation, but this is the most significant.
     *
     * `Request` instances are typically created by higher-level classes, like {\@link Http} and
     * {\@link Jsonp}, but it may occasionally be useful to explicitly create `Request` instances.
     * One such example is when creating services that wrap higher-level services, like {\@link Http},
     * where it may be useful to generate a `Request` with arbitrary headers and search params.
     *
     * ```typescript
     * import {Injectable, Injector} from '\@angular/core';
     * import {HTTP_PROVIDERS, Http, Request, RequestMethod} from '\@angular/http';
     *
     * \@Injectable()
     * class AutoAuthenticator {
     *   constructor(public http:Http) {}
     *   request(url:string) {
     *     return this.http.request(new Request({
     *       method: RequestMethod.Get,
     *       url: url,
     *       search: 'password=123'
     *     }));
     *   }
     * }
     *
     * var injector = Injector.resolveAndCreate([HTTP_PROVIDERS, AutoAuthenticator]);
     * var authenticator = injector.get(AutoAuthenticator);
     * authenticator.request('people.json').subscribe(res => {
     *   //URL should have included '?password=123'
     *   console.log('people', res.json());
     * });
     * ```
     *
     * \@experimental
     */
    var Request = (function (_super) {
        __extends$5(Request, _super);
        /**
         * @param {?} requestOptions
         */
        function Request(requestOptions) {
            _super.call(this);
            // TODO: assert that url is present
            var url = requestOptions.url;
            this.url = requestOptions.url;
            if (requestOptions.search) {
                var search = requestOptions.search.toString();
                if (search.length > 0) {
                    var prefix = '?';
                    if (this.url.indexOf('?') != -1) {
                        prefix = (this.url[this.url.length - 1] == '&') ? '' : '&';
                    }
                    // TODO: just delete search-query-looking string in url?
                    this.url = url + prefix + search;
                }
            }
            this._body = requestOptions.body;
            this.method = normalizeMethodName(requestOptions.method);
            // TODO(jeffbcross): implement behavior
            // Defaults to 'omit', consistent with browser
            this.headers = new Headers(requestOptions.headers);
            this.contentType = this.detectContentType();
            this.withCredentials = requestOptions.withCredentials;
            this.responseType = requestOptions.responseType;
        }
        /**
         * Returns the content type enum based on header options.
         * @return {?}
         */
        Request.prototype.detectContentType = function () {
            switch (this.headers.get('content-type')) {
                case 'application/json':
                    return ContentType.JSON;
                case 'application/x-www-form-urlencoded':
                    return ContentType.FORM;
                case 'multipart/form-data':
                    return ContentType.FORM_DATA;
                case 'text/plain':
                case 'text/html':
                    return ContentType.TEXT;
                case 'application/octet-stream':
                    return this._body instanceof ArrayBuffer$1 ? ContentType.ARRAY_BUFFER : ContentType.BLOB;
                default:
                    return this.detectContentTypeFromBody();
            }
        };
        /**
         * Returns the content type of request's body based on its type.
         * @return {?}
         */
        Request.prototype.detectContentTypeFromBody = function () {
            if (this._body == null) {
                return ContentType.NONE;
            }
            else if (this._body instanceof URLSearchParams) {
                return ContentType.FORM;
            }
            else if (this._body instanceof FormData) {
                return ContentType.FORM_DATA;
            }
            else if (this._body instanceof Blob$1) {
                return ContentType.BLOB;
            }
            else if (this._body instanceof ArrayBuffer$1) {
                return ContentType.ARRAY_BUFFER;
            }
            else if (this._body && typeof this._body === 'object') {
                return ContentType.JSON;
            }
            else {
                return ContentType.TEXT;
            }
        };
        /**
         * Returns the request's body according to its type. If body is undefined, return
         * null.
         * @return {?}
         */
        Request.prototype.getBody = function () {
            switch (this.contentType) {
                case ContentType.JSON:
                    return this.text();
                case ContentType.FORM:
                    return this.text();
                case ContentType.FORM_DATA:
                    return this._body;
                case ContentType.TEXT:
                    return this.text();
                case ContentType.BLOB:
                    return this.blob();
                case ContentType.ARRAY_BUFFER:
                    return this.arrayBuffer();
                default:
                    return null;
            }
        };
        return Request;
    }(Body));
    var /** @type {?} */ noop = function () { };
    var /** @type {?} */ w = typeof window == 'object' ? window : noop;
    var /** @type {?} */ FormData = ((w) /** TODO #9100 */)['FormData'] || noop;
    var /** @type {?} */ Blob$1 = ((w) /** TODO #9100 */)['Blob'] || noop;
    var /** @type {?} */ ArrayBuffer$1 = ((w) /** TODO #9100 */)['ArrayBuffer'] || noop;

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    var __extends$4 = (this && this.__extends) || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
    /**
     * @param {?} backend
     * @param {?} request
     * @return {?}
     */
    function httpRequest(backend, request) {
        return backend.createConnection(request).response;
    }
    /**
     * @param {?} defaultOpts
     * @param {?} providedOpts
     * @param {?} method
     * @param {?} url
     * @return {?}
     */
    function mergeOptions(defaultOpts, providedOpts, method, url) {
        var /** @type {?} */ newOptions = defaultOpts;
        if (providedOpts) {
            // Hack so Dart can used named parameters
            return newOptions.merge(new RequestOptions({
                method: providedOpts.method || method,
                url: providedOpts.url || url,
                search: providedOpts.search,
                headers: providedOpts.headers,
                body: providedOpts.body,
                withCredentials: providedOpts.withCredentials,
                responseType: providedOpts.responseType
            }));
        }
        return newOptions.merge(new RequestOptions({ method: method, url: url }));
    }
    /**
     * Performs http requests using `XMLHttpRequest` as the default backend.
     *
     * `Http` is available as an injectable class, with methods to perform http requests. Calling
     * `request` returns an `Observable` which will emit a single {\@link Response} when a
     * response is received.
     *
     * ### Example
     *
     * ```typescript
     * import {Http, HTTP_PROVIDERS} from '\@angular/http';
     * import 'rxjs/add/operator/map'
     * \@Component({
     *   selector: 'http-app',
     *   viewProviders: [HTTP_PROVIDERS],
     *   templateUrl: 'people.html'
     * })
     * class PeopleComponent {
     *   constructor(http: Http) {
     *     http.get('people.json')
     *       // Call map on the response observable to get the parsed people object
     *       .map(res => res.json())
     *       // Subscribe to the observable to get the parsed people object and attach it to the
     *       // component
     *       .subscribe(people => this.people = people);
     *   }
     * }
     * ```
     *
     *
     * ### Example
     *
     * ```
     * http.get('people.json').subscribe((res:Response) => this.people = res.json());
     * ```
     *
     * The default construct used to perform requests, `XMLHttpRequest`, is abstracted as a "Backend" (
     * {\@link XHRBackend} in this case), which could be mocked with dependency injection by replacing
     * the {\@link XHRBackend} provider, as in the following example:
     *
     * ### Example
     *
     * ```typescript
     * import {BaseRequestOptions, Http} from '\@angular/http';
     * import {MockBackend} from '\@angular/http/testing';
     * var injector = Injector.resolveAndCreate([
     *   BaseRequestOptions,
     *   MockBackend,
     *   {provide: Http, useFactory:
     *       function(backend, defaultOptions) {
     *         return new Http(backend, defaultOptions);
     *       },
     *       deps: [MockBackend, BaseRequestOptions]}
     * ]);
     * var http = injector.get(Http);
     * http.get('request-from-mock-backend.json').subscribe((res:Response) => doSomething(res));
     * ```
     *
     * \@experimental
     */
    var Http = (function () {
        /**
         * @param {?} _backend
         * @param {?} _defaultOptions
         */
        function Http(_backend, _defaultOptions) {
            this._backend = _backend;
            this._defaultOptions = _defaultOptions;
        }
        /**
         * Performs any type of http request. First argument is required, and can either be a url or
         * a {\@link Request} instance. If the first argument is a url, an optional {\@link RequestOptions}
         * object can be provided as the 2nd argument. The options object will be merged with the values
         * of {\@link BaseRequestOptions} before performing the request.
         * @param {?} url
         * @param {?=} options
         * @return {?}
         */
        Http.prototype.request = function (url, options) {
            var /** @type {?} */ responseObservable;
            if (typeof url === 'string') {
                responseObservable = httpRequest(this._backend, new Request(mergeOptions(this._defaultOptions, options, RequestMethod.Get, /** @type {?} */ (url))));
            }
            else if (url instanceof Request) {
                responseObservable = httpRequest(this._backend, url);
            }
            else {
                throw new Error('First argument must be a url string or Request instance.');
            }
            return responseObservable;
        };
        /**
         * Performs a request with `get` http method.
         * @param {?} url
         * @param {?=} options
         * @return {?}
         */
        Http.prototype.get = function (url, options) {
            return this.request(new Request(mergeOptions(this._defaultOptions, options, RequestMethod.Get, url)));
        };
        /**
         * Performs a request with `post` http method.
         * @param {?} url
         * @param {?} body
         * @param {?=} options
         * @return {?}
         */
        Http.prototype.post = function (url, body, options) {
            return this.request(new Request(mergeOptions(this._defaultOptions.merge(new RequestOptions({ body: body })), options, RequestMethod.Post, url)));
        };
        /**
         * Performs a request with `put` http method.
         * @param {?} url
         * @param {?} body
         * @param {?=} options
         * @return {?}
         */
        Http.prototype.put = function (url, body, options) {
            return this.request(new Request(mergeOptions(this._defaultOptions.merge(new RequestOptions({ body: body })), options, RequestMethod.Put, url)));
        };
        /**
         * Performs a request with `delete` http method.
         * @param {?} url
         * @param {?=} options
         * @return {?}
         */
        Http.prototype.delete = function (url, options) {
            return this.request(new Request(mergeOptions(this._defaultOptions, options, RequestMethod.Delete, url)));
        };
        /**
         * Performs a request with `patch` http method.
         * @param {?} url
         * @param {?} body
         * @param {?=} options
         * @return {?}
         */
        Http.prototype.patch = function (url, body, options) {
            return this.request(new Request(mergeOptions(this._defaultOptions.merge(new RequestOptions({ body: body })), options, RequestMethod.Patch, url)));
        };
        /**
         * Performs a request with `head` http method.
         * @param {?} url
         * @param {?=} options
         * @return {?}
         */
        Http.prototype.head = function (url, options) {
            return this.request(new Request(mergeOptions(this._defaultOptions, options, RequestMethod.Head, url)));
        };
        /**
         * Performs a request with `options` http method.
         * @param {?} url
         * @param {?=} options
         * @return {?}
         */
        Http.prototype.options = function (url, options) {
            return this.request(new Request(mergeOptions(this._defaultOptions, options, RequestMethod.Options, url)));
        };
        /** @nocollapse */
        Http.ctorParameters = function () { return [
            { type: ConnectionBackend, },
            { type: RequestOptions, },
        ]; };
Http.ɵfac = function Http_Factory(t) { return new (t || Http)(ɵngcc0.ɵɵinject(ConnectionBackend), ɵngcc0.ɵɵinject(RequestOptions)); };
Http.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: Http, factory: function (t) { return Http.ɵfac(t); } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(Http, [{
        type: _angular_core.Injectable
    }], function () { return [{ type: ConnectionBackend }, { type: RequestOptions }]; }, null); })();
        return Http;
    }());
    /**
     * \@experimental
     */
    var Jsonp = (function (_super) {
        __extends$4(Jsonp, _super);
        /**
         * @param {?} backend
         * @param {?} defaultOptions
         */
        function Jsonp(backend, defaultOptions) {
            _super.call(this, backend, defaultOptions);
        }
        /**
         * Performs any type of http request. First argument is required, and can either be a url or
         * a {\@link Request} instance. If the first argument is a url, an optional {\@link RequestOptions}
         * object can be provided as the 2nd argument. The options object will be merged with the values
         * of {\@link BaseRequestOptions} before performing the request.
         *
         * \@security Regular XHR is the safest alternative to JSONP for most applications, and is
         * supported by all current browsers. Because JSONP creates a `<script>` element with
         * contents retrieved from a remote source, attacker-controlled data introduced by an untrusted
         * source could expose your application to XSS risks. Data exposed by JSONP may also be
         * readable by malicious third-party websites. In addition, JSONP introduces potential risk for
         * future security issues (e.g. content sniffing).  For more detail, see the
         * [Security Guide](http://g.co/ng/security).
         * @param {?} url
         * @param {?=} options
         * @return {?}
         */
        Jsonp.prototype.request = function (url, options) {
            var /** @type {?} */ responseObservable;
            if (typeof url === 'string') {
                url =
                    new Request(mergeOptions(this._defaultOptions, options, RequestMethod.Get, /** @type {?} */ (url)));
            }
            if (url instanceof Request) {
                if (url.method !== RequestMethod.Get) {
                    throw new Error('JSONP requests must use GET request method.');
                }
                responseObservable = httpRequest(this._backend, url);
            }
            else {
                throw new Error('First argument must be a url string or Request instance.');
            }
            return responseObservable;
        };
        /** @nocollapse */
        Jsonp.ctorParameters = function () { return [
            { type: ConnectionBackend, },
            { type: RequestOptions, },
        ]; };
Jsonp.ɵfac = function Jsonp_Factory(t) { return new (t || Jsonp)(ɵngcc0.ɵɵinject(ConnectionBackend), ɵngcc0.ɵɵinject(RequestOptions)); };
Jsonp.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: Jsonp, factory: function (t) { return Jsonp.ɵfac(t); } });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(Jsonp, [{
        type: _angular_core.Injectable
    }], function () { return [{ type: ConnectionBackend }, { type: RequestOptions }]; }, null); })();
        return Jsonp;
    }(Http));

    /**
     * @return {?}
     */
    function _createDefaultCookieXSRFStrategy() {
        return new CookieXSRFStrategy();
    }
    /**
     * @param {?} xhrBackend
     * @param {?} requestOptions
     * @return {?}
     */
    function httpFactory(xhrBackend, requestOptions) {
        return new Http(xhrBackend, requestOptions);
    }
    /**
     * @param {?} jsonpBackend
     * @param {?} requestOptions
     * @return {?}
     */
    function jsonpFactory(jsonpBackend, requestOptions) {
        return new Jsonp(jsonpBackend, requestOptions);
    }
    /**
     * The module that includes http's providers
     *
     * \@experimental
     */
    var HttpModule = (function () {
        function HttpModule() {
        }
        /** @nocollapse */
        HttpModule.ctorParameters = function () { return []; };
HttpModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: HttpModule });
HttpModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function HttpModule_Factory(t) { return new (t || HttpModule)(); }, providers: [
        // TODO(pascal): use factory type annotations once supported in DI
        // issue: https://github.com/angular/angular/issues/3183
        { provide: Http, useFactory: httpFactory, deps: [XHRBackend, RequestOptions] },
        BrowserXhr,
        { provide: RequestOptions, useClass: BaseRequestOptions },
        { provide: ResponseOptions, useClass: BaseResponseOptions },
        XHRBackend,
        { provide: XSRFStrategy, useFactory: _createDefaultCookieXSRFStrategy },
    ] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(HttpModule, [{
        type: _angular_core.NgModule,
        args: [{
                providers: [
                    // TODO(pascal): use factory type annotations once supported in DI
                    // issue: https://github.com/angular/angular/issues/3183
                    { provide: Http, useFactory: httpFactory, deps: [XHRBackend, RequestOptions] },
                    BrowserXhr,
                    { provide: RequestOptions, useClass: BaseRequestOptions },
                    { provide: ResponseOptions, useClass: BaseResponseOptions },
                    XHRBackend,
                    { provide: XSRFStrategy, useFactory: _createDefaultCookieXSRFStrategy },
                ]
            }]
    }], function () { return []; }, null); })();
        return HttpModule;
    }());
    /**
     * The module that includes jsonp's providers
     *
     * \@experimental
     */
    var JsonpModule = (function () {
        function JsonpModule() {
        }
        /** @nocollapse */
        JsonpModule.ctorParameters = function () { return []; };
JsonpModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: JsonpModule });
JsonpModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function JsonpModule_Factory(t) { return new (t || JsonpModule)(); }, providers: [
        // TODO(pascal): use factory type annotations once supported in DI
        // issue: https://github.com/angular/angular/issues/3183
        { provide: Jsonp, useFactory: jsonpFactory, deps: [JSONPBackend, RequestOptions] },
        BrowserJsonp,
        { provide: RequestOptions, useClass: BaseRequestOptions },
        { provide: ResponseOptions, useClass: BaseResponseOptions },
        { provide: JSONPBackend, useClass: JSONPBackend_ },
    ] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(JsonpModule, [{
        type: _angular_core.NgModule,
        args: [{
                providers: [
                    // TODO(pascal): use factory type annotations once supported in DI
                    // issue: https://github.com/angular/angular/issues/3183
                    { provide: Jsonp, useFactory: jsonpFactory, deps: [JSONPBackend, RequestOptions] },
                    BrowserJsonp,
                    { provide: RequestOptions, useClass: BaseRequestOptions },
                    { provide: ResponseOptions, useClass: BaseResponseOptions },
                    { provide: JSONPBackend, useClass: JSONPBackend_ },
                ]
            }]
    }], function () { return []; }, null); })();
        return JsonpModule;
    }());

    /**
     * @stable
     */
    var /** @type {?} */ VERSION = new _angular_core.Version('2.4.10');

    exports.BrowserXhr = BrowserXhr;
    exports.JSONPBackend = JSONPBackend;
    exports.JSONPConnection = JSONPConnection;
    exports.CookieXSRFStrategy = CookieXSRFStrategy;
    exports.XHRBackend = XHRBackend;
    exports.XHRConnection = XHRConnection;
    exports.BaseRequestOptions = BaseRequestOptions;
    exports.RequestOptions = RequestOptions;
    exports.BaseResponseOptions = BaseResponseOptions;
    exports.ResponseOptions = ResponseOptions;
    exports.ReadyState = ReadyState;
    exports.RequestMethod = RequestMethod;
    exports.ResponseContentType = ResponseContentType;
    exports.ResponseType = ResponseType;
    exports.Headers = Headers;
    exports.Http = Http;
    exports.Jsonp = Jsonp;
    exports.HttpModule = HttpModule;
    exports.JsonpModule = JsonpModule;
    exports.Connection = Connection;
    exports.ConnectionBackend = ConnectionBackend;
    exports.XSRFStrategy = XSRFStrategy;
    exports.Request = Request;
    exports.Response = Response;
    exports.QueryEncoder = QueryEncoder;
    exports.URLSearchParams = URLSearchParams;
    exports.VERSION = VERSION;

}));
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaHR0cC51bWQuanMiLCJzb3VyY2VzIjpbImh0dHAudW1kLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9HQUEyRTtBQUMzRSx5RUFBeUQ7QUFDekQsNEJBQWE7QUFDYix5QkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNGQUdVO0FBQ1Y7QUFDQTs7Ozs7Z0RBQStEO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBR1U7QUFDVjtBQUNBOzs7OztnREFBd0U7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFHVTtBQUNWO0FBQ0E7Ozs7O2dEQUFpRTtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBR1U7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztpR0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUdVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozt1SEFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FHVTtBQUNWO0FBQ0E7Ozs7O2dEQUF1RTtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFHVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O3FHQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBR1U7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztxR0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQWNVO0FBQ1Y7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Z0RBQStEO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBYVU7QUFDVjtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Z0RBQWdFO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZSBBbmd1bGFyIHYyLjQuMTBcbiAqIChjKSAyMDEwLTIwMTcgR29vZ2xlLCBJbmMuIGh0dHBzOi8vYW5ndWxhci5pby9cbiAqIExpY2Vuc2U6IE1JVFxuICovXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkoZXhwb3J0cywgcmVxdWlyZSgnQGFuZ3VsYXIvY29yZScpLCByZXF1aXJlKCdyeGpzL09ic2VydmFibGUnKSwgcmVxdWlyZSgnQGFuZ3VsYXIvcGxhdGZvcm0tYnJvd3NlcicpKSA6XG4gICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnZXhwb3J0cycsICdAYW5ndWxhci9jb3JlJywgJ3J4anMvT2JzZXJ2YWJsZScsICdAYW5ndWxhci9wbGF0Zm9ybS1icm93c2VyJ10sIGZhY3RvcnkpIDpcbiAgICAoZmFjdG9yeSgoZ2xvYmFsLm5nID0gZ2xvYmFsLm5nIHx8IHt9LCBnbG9iYWwubmcuaHR0cCA9IGdsb2JhbC5uZy5odHRwIHx8IHt9KSxnbG9iYWwubmcuY29yZSxnbG9iYWwuUngsZ2xvYmFsLm5nLnBsYXRmb3JtQnJvd3NlcikpO1xufSh0aGlzLCBmdW5jdGlvbiAoZXhwb3J0cyxfYW5ndWxhcl9jb3JlLHJ4anNfT2JzZXJ2YWJsZSxfYW5ndWxhcl9wbGF0Zm9ybUJyb3dzZXIpIHsgJ3VzZSBzdHJpY3QnO1xuXG4gICAgLyoqXG4gICAgICogQSBiYWNrZW5kIGZvciBodHRwIHRoYXQgdXNlcyB0aGUgYFhNTEh0dHBSZXF1ZXN0YCBicm93c2VyIEFQSS5cbiAgICAgKlxuICAgICAqIFRha2UgY2FyZSBub3QgdG8gZXZhbHVhdGUgdGhpcyBpbiBub24tYnJvd3NlciBjb250ZXh0cy5cbiAgICAgKlxuICAgICAqIFxcQGV4cGVyaW1lbnRhbFxuICAgICAqL1xuICAgIHZhciBCcm93c2VyWGhyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gQnJvd3NlclhocigpIHtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIEJyb3dzZXJYaHIucHJvdG90eXBlLmJ1aWxkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gKChuZXcgWE1MSHR0cFJlcXVlc3QoKSkpOyB9O1xuICAgICAgICBCcm93c2VyWGhyLmRlY29yYXRvcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5qZWN0YWJsZSB9LFxuICAgICAgICBdO1xuICAgICAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICAgICAgQnJvd3Nlclhoci5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtdOyB9O1xuICAgICAgICByZXR1cm4gQnJvd3NlclhocjtcbiAgICB9KCkpO1xuXG4gICAgdmFyIFJlcXVlc3RNZXRob2QgPSB7fTtcbiAgICBSZXF1ZXN0TWV0aG9kLkdldCA9IDA7XG4gICAgUmVxdWVzdE1ldGhvZC5Qb3N0ID0gMTtcbiAgICBSZXF1ZXN0TWV0aG9kLlB1dCA9IDI7XG4gICAgUmVxdWVzdE1ldGhvZC5EZWxldGUgPSAzO1xuICAgIFJlcXVlc3RNZXRob2QuT3B0aW9ucyA9IDQ7XG4gICAgUmVxdWVzdE1ldGhvZC5IZWFkID0gNTtcbiAgICBSZXF1ZXN0TWV0aG9kLlBhdGNoID0gNjtcbiAgICBSZXF1ZXN0TWV0aG9kW1JlcXVlc3RNZXRob2QuR2V0XSA9IFwiR2V0XCI7XG4gICAgUmVxdWVzdE1ldGhvZFtSZXF1ZXN0TWV0aG9kLlBvc3RdID0gXCJQb3N0XCI7XG4gICAgUmVxdWVzdE1ldGhvZFtSZXF1ZXN0TWV0aG9kLlB1dF0gPSBcIlB1dFwiO1xuICAgIFJlcXVlc3RNZXRob2RbUmVxdWVzdE1ldGhvZC5EZWxldGVdID0gXCJEZWxldGVcIjtcbiAgICBSZXF1ZXN0TWV0aG9kW1JlcXVlc3RNZXRob2QuT3B0aW9uc10gPSBcIk9wdGlvbnNcIjtcbiAgICBSZXF1ZXN0TWV0aG9kW1JlcXVlc3RNZXRob2QuSGVhZF0gPSBcIkhlYWRcIjtcbiAgICBSZXF1ZXN0TWV0aG9kW1JlcXVlc3RNZXRob2QuUGF0Y2hdID0gXCJQYXRjaFwiO1xuICAgIHZhciBSZWFkeVN0YXRlID0ge307XG4gICAgUmVhZHlTdGF0ZS5VbnNlbnQgPSAwO1xuICAgIFJlYWR5U3RhdGUuT3BlbiA9IDE7XG4gICAgUmVhZHlTdGF0ZS5IZWFkZXJzUmVjZWl2ZWQgPSAyO1xuICAgIFJlYWR5U3RhdGUuTG9hZGluZyA9IDM7XG4gICAgUmVhZHlTdGF0ZS5Eb25lID0gNDtcbiAgICBSZWFkeVN0YXRlLkNhbmNlbGxlZCA9IDU7XG4gICAgUmVhZHlTdGF0ZVtSZWFkeVN0YXRlLlVuc2VudF0gPSBcIlVuc2VudFwiO1xuICAgIFJlYWR5U3RhdGVbUmVhZHlTdGF0ZS5PcGVuXSA9IFwiT3BlblwiO1xuICAgIFJlYWR5U3RhdGVbUmVhZHlTdGF0ZS5IZWFkZXJzUmVjZWl2ZWRdID0gXCJIZWFkZXJzUmVjZWl2ZWRcIjtcbiAgICBSZWFkeVN0YXRlW1JlYWR5U3RhdGUuTG9hZGluZ10gPSBcIkxvYWRpbmdcIjtcbiAgICBSZWFkeVN0YXRlW1JlYWR5U3RhdGUuRG9uZV0gPSBcIkRvbmVcIjtcbiAgICBSZWFkeVN0YXRlW1JlYWR5U3RhdGUuQ2FuY2VsbGVkXSA9IFwiQ2FuY2VsbGVkXCI7XG4gICAgdmFyIFJlc3BvbnNlVHlwZSA9IHt9O1xuICAgIFJlc3BvbnNlVHlwZS5CYXNpYyA9IDA7XG4gICAgUmVzcG9uc2VUeXBlLkNvcnMgPSAxO1xuICAgIFJlc3BvbnNlVHlwZS5EZWZhdWx0ID0gMjtcbiAgICBSZXNwb25zZVR5cGUuRXJyb3IgPSAzO1xuICAgIFJlc3BvbnNlVHlwZS5PcGFxdWUgPSA0O1xuICAgIFJlc3BvbnNlVHlwZVtSZXNwb25zZVR5cGUuQmFzaWNdID0gXCJCYXNpY1wiO1xuICAgIFJlc3BvbnNlVHlwZVtSZXNwb25zZVR5cGUuQ29yc10gPSBcIkNvcnNcIjtcbiAgICBSZXNwb25zZVR5cGVbUmVzcG9uc2VUeXBlLkRlZmF1bHRdID0gXCJEZWZhdWx0XCI7XG4gICAgUmVzcG9uc2VUeXBlW1Jlc3BvbnNlVHlwZS5FcnJvcl0gPSBcIkVycm9yXCI7XG4gICAgUmVzcG9uc2VUeXBlW1Jlc3BvbnNlVHlwZS5PcGFxdWVdID0gXCJPcGFxdWVcIjtcbiAgICB2YXIgQ29udGVudFR5cGUgPSB7fTtcbiAgICBDb250ZW50VHlwZS5OT05FID0gMDtcbiAgICBDb250ZW50VHlwZS5KU09OID0gMTtcbiAgICBDb250ZW50VHlwZS5GT1JNID0gMjtcbiAgICBDb250ZW50VHlwZS5GT1JNX0RBVEEgPSAzO1xuICAgIENvbnRlbnRUeXBlLlRFWFQgPSA0O1xuICAgIENvbnRlbnRUeXBlLkJMT0IgPSA1O1xuICAgIENvbnRlbnRUeXBlLkFSUkFZX0JVRkZFUiA9IDY7XG4gICAgQ29udGVudFR5cGVbQ29udGVudFR5cGUuTk9ORV0gPSBcIk5PTkVcIjtcbiAgICBDb250ZW50VHlwZVtDb250ZW50VHlwZS5KU09OXSA9IFwiSlNPTlwiO1xuICAgIENvbnRlbnRUeXBlW0NvbnRlbnRUeXBlLkZPUk1dID0gXCJGT1JNXCI7XG4gICAgQ29udGVudFR5cGVbQ29udGVudFR5cGUuRk9STV9EQVRBXSA9IFwiRk9STV9EQVRBXCI7XG4gICAgQ29udGVudFR5cGVbQ29udGVudFR5cGUuVEVYVF0gPSBcIlRFWFRcIjtcbiAgICBDb250ZW50VHlwZVtDb250ZW50VHlwZS5CTE9CXSA9IFwiQkxPQlwiO1xuICAgIENvbnRlbnRUeXBlW0NvbnRlbnRUeXBlLkFSUkFZX0JVRkZFUl0gPSBcIkFSUkFZX0JVRkZFUlwiO1xuICAgIHZhciBSZXNwb25zZUNvbnRlbnRUeXBlID0ge307XG4gICAgUmVzcG9uc2VDb250ZW50VHlwZS5UZXh0ID0gMDtcbiAgICBSZXNwb25zZUNvbnRlbnRUeXBlLkpzb24gPSAxO1xuICAgIFJlc3BvbnNlQ29udGVudFR5cGUuQXJyYXlCdWZmZXIgPSAyO1xuICAgIFJlc3BvbnNlQ29udGVudFR5cGUuQmxvYiA9IDM7XG4gICAgUmVzcG9uc2VDb250ZW50VHlwZVtSZXNwb25zZUNvbnRlbnRUeXBlLlRleHRdID0gXCJUZXh0XCI7XG4gICAgUmVzcG9uc2VDb250ZW50VHlwZVtSZXNwb25zZUNvbnRlbnRUeXBlLkpzb25dID0gXCJKc29uXCI7XG4gICAgUmVzcG9uc2VDb250ZW50VHlwZVtSZXNwb25zZUNvbnRlbnRUeXBlLkFycmF5QnVmZmVyXSA9IFwiQXJyYXlCdWZmZXJcIjtcbiAgICBSZXNwb25zZUNvbnRlbnRUeXBlW1Jlc3BvbnNlQ29udGVudFR5cGUuQmxvYl0gPSBcIkJsb2JcIjtcblxuICAgIC8qKlxuICAgICAqIFBvbHlmaWxsIGZvciBbSGVhZGVyc10oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0hlYWRlcnMvSGVhZGVycyksIGFzXG4gICAgICogc3BlY2lmaWVkIGluIHRoZSBbRmV0Y2ggU3BlY10oaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2hlYWRlcnMtY2xhc3MpLlxuICAgICAqXG4gICAgICogVGhlIG9ubHkga25vd24gZGlmZmVyZW5jZSBiZXR3ZWVuIHRoaXMgYEhlYWRlcnNgIGltcGxlbWVudGF0aW9uIGFuZCB0aGUgc3BlYyBpcyB0aGVcbiAgICAgKiBsYWNrIG9mIGFuIGBlbnRyaWVzYCBtZXRob2QuXG4gICAgICpcbiAgICAgKiAjIyMgRXhhbXBsZVxuICAgICAqXG4gICAgICogYGBgXG4gICAgICogaW1wb3J0IHtIZWFkZXJzfSBmcm9tICdcXEBhbmd1bGFyL2h0dHAnO1xuICAgICAqXG4gICAgICogdmFyIGZpcnN0SGVhZGVycyA9IG5ldyBIZWFkZXJzKCk7XG4gICAgICogZmlyc3RIZWFkZXJzLmFwcGVuZCgnQ29udGVudC1UeXBlJywgJ2ltYWdlL2pwZWcnKTtcbiAgICAgKiBjb25zb2xlLmxvZyhmaXJzdEhlYWRlcnMuZ2V0KCdDb250ZW50LVR5cGUnKSkgLy8naW1hZ2UvanBlZydcbiAgICAgKlxuICAgICAqIC8vIENyZWF0ZSBoZWFkZXJzIGZyb20gUGxhaW4gT2xkIEphdmFTY3JpcHQgT2JqZWN0XG4gICAgICogdmFyIHNlY29uZEhlYWRlcnMgPSBuZXcgSGVhZGVycyh7XG4gICAgICogICAnWC1NeS1DdXN0b20tSGVhZGVyJzogJ0FuZ3VsYXInXG4gICAgICogfSk7XG4gICAgICogY29uc29sZS5sb2coc2Vjb25kSGVhZGVycy5nZXQoJ1gtTXktQ3VzdG9tLUhlYWRlcicpKTsgLy8nQW5ndWxhcidcbiAgICAgKlxuICAgICAqIHZhciB0aGlyZEhlYWRlcnMgPSBuZXcgSGVhZGVycyhzZWNvbmRIZWFkZXJzKTtcbiAgICAgKiBjb25zb2xlLmxvZyh0aGlyZEhlYWRlcnMuZ2V0KCdYLU15LUN1c3RvbS1IZWFkZXInKSk7IC8vJ0FuZ3VsYXInXG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBcXEBleHBlcmltZW50YWxcbiAgICAgKi9cbiAgICB2YXIgSGVhZGVycyA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez89fSBoZWFkZXJzXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBIZWFkZXJzKGhlYWRlcnMpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICAvKiogQGludGVybmFsIGhlYWRlciBuYW1lcyBhcmUgbG93ZXIgY2FzZSAqL1xuICAgICAgICAgICAgdGhpcy5faGVhZGVycyA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgIC8qKiBAaW50ZXJuYWwgbWFwIGxvd2VyIGNhc2UgbmFtZXMgdG8gYWN0dWFsIG5hbWVzICovXG4gICAgICAgICAgICB0aGlzLl9ub3JtYWxpemVkTmFtZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICBpZiAoIWhlYWRlcnMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaGVhZGVycyBpbnN0YW5jZW9mIEhlYWRlcnMpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJzLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlcywgbmFtZSkge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZXMuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIF90aGlzLmFwcGVuZChuYW1lLCB2YWx1ZSk7IH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIE9iamVjdC5rZXlzKGhlYWRlcnMpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWVzID0gQXJyYXkuaXNBcnJheShoZWFkZXJzW25hbWVdKSA/IGhlYWRlcnNbbmFtZV0gOiBbaGVhZGVyc1tuYW1lXV07XG4gICAgICAgICAgICAgICAgX3RoaXMuZGVsZXRlKG5hbWUpO1xuICAgICAgICAgICAgICAgIHZhbHVlcy5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gX3RoaXMuYXBwZW5kKG5hbWUsIHZhbHVlKTsgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyBhIG5ldyBIZWFkZXJzIGluc3RhbmNlIGZyb20gdGhlIGdpdmVuIERPTVN0cmluZyBvZiBSZXNwb25zZSBIZWFkZXJzXG4gICAgICAgICAqIEBwYXJhbSB7P30gaGVhZGVyc1N0cmluZ1xuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgSGVhZGVycy5mcm9tUmVzcG9uc2VIZWFkZXJTdHJpbmcgPSBmdW5jdGlvbiAoaGVhZGVyc1N0cmluZykge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaGVhZGVycyA9IG5ldyBIZWFkZXJzKCk7XG4gICAgICAgICAgICBoZWFkZXJzU3RyaW5nLnNwbGl0KCdcXG4nKS5mb3JFYWNoKGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gaW5kZXggPSBsaW5lLmluZGV4T2YoJzonKTtcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG5hbWVfMSA9IGxpbmUuc2xpY2UoMCwgaW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyB2YWx1ZSA9IGxpbmUuc2xpY2UoaW5kZXggKyAxKS50cmltKCk7XG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnMuc2V0KG5hbWVfMSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGhlYWRlcnM7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBcHBlbmRzIGEgaGVhZGVyIHRvIGV4aXN0aW5nIGxpc3Qgb2YgaGVhZGVyIHZhbHVlcyBmb3IgYSBnaXZlbiBoZWFkZXIgbmFtZS5cbiAgICAgICAgICogQHBhcmFtIHs/fSBuYW1lXG4gICAgICAgICAqIEBwYXJhbSB7P30gdmFsdWVcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIEhlYWRlcnMucHJvdG90eXBlLmFwcGVuZCA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdmFsdWVzID0gdGhpcy5nZXRBbGwobmFtZSk7XG4gICAgICAgICAgICBpZiAodmFsdWVzID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXQobmFtZSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFsdWVzLnB1c2godmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogRGVsZXRlcyBhbGwgaGVhZGVyIHZhbHVlcyBmb3IgdGhlIGdpdmVuIG5hbWUuXG4gICAgICAgICAqIEBwYXJhbSB7P30gbmFtZVxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgSGVhZGVycy5wcm90b3R5cGUuZGVsZXRlID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGxjTmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIHRoaXMuX25vcm1hbGl6ZWROYW1lcy5kZWxldGUobGNOYW1lKTtcbiAgICAgICAgICAgIHRoaXMuX2hlYWRlcnMuZGVsZXRlKGxjTmFtZSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IGZuXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBIZWFkZXJzLnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgdGhpcy5faGVhZGVycy5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZXMsIGxjTmFtZSkgeyByZXR1cm4gZm4odmFsdWVzLCBfdGhpcy5fbm9ybWFsaXplZE5hbWVzLmdldChsY05hbWUpLCBfdGhpcy5faGVhZGVycyk7IH0pO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyBmaXJzdCBoZWFkZXIgdGhhdCBtYXRjaGVzIGdpdmVuIG5hbWUuXG4gICAgICAgICAqIEBwYXJhbSB7P30gbmFtZVxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgSGVhZGVycy5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHZhbHVlcyA9IHRoaXMuZ2V0QWxsKG5hbWUpO1xuICAgICAgICAgICAgaWYgKHZhbHVlcyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlcy5sZW5ndGggPiAwID8gdmFsdWVzWzBdIDogbnVsbDtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENoZWNrcyBmb3IgZXhpc3RlbmNlIG9mIGhlYWRlciBieSBnaXZlbiBuYW1lLlxuICAgICAgICAgKiBAcGFyYW0gez99IG5hbWVcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIEhlYWRlcnMucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiB0aGlzLl9oZWFkZXJzLmhhcyhuYW1lLnRvTG93ZXJDYXNlKCkpOyB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyB0aGUgbmFtZXMgb2YgdGhlIGhlYWRlcnNcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIEhlYWRlcnMucHJvdG90eXBlLmtleXMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBBcnJheS5mcm9tKHRoaXMuX25vcm1hbGl6ZWROYW1lcy52YWx1ZXMoKSk7IH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXRzIG9yIG92ZXJyaWRlcyBoZWFkZXIgdmFsdWUgZm9yIGdpdmVuIG5hbWUuXG4gICAgICAgICAqIEBwYXJhbSB7P30gbmFtZVxuICAgICAgICAgKiBAcGFyYW0gez99IHZhbHVlXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBIZWFkZXJzLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAobmFtZSwgdmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faGVhZGVycy5zZXQobmFtZS50b0xvd2VyQ2FzZSgpLCBbdmFsdWUuam9pbignLCcpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5faGVhZGVycy5zZXQobmFtZS50b0xvd2VyQ2FzZSgpLCBbdmFsdWVdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMubWF5QmVTZXROb3JtYWxpemVkTmFtZShuYW1lKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgdmFsdWVzIG9mIGFsbCBoZWFkZXJzLlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgSGVhZGVycy5wcm90b3R5cGUudmFsdWVzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLl9oZWFkZXJzLnZhbHVlcygpKTsgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBIZWFkZXJzLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gc2VyaWFsaXplZCA9IHt9O1xuICAgICAgICAgICAgdGhpcy5faGVhZGVycy5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZXMsIG5hbWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzcGxpdCA9IFtdO1xuICAgICAgICAgICAgICAgIHZhbHVlcy5mb3JFYWNoKGZ1bmN0aW9uICh2KSB7IHJldHVybiBzcGxpdC5wdXNoLmFwcGx5KHNwbGl0LCB2LnNwbGl0KCcsJykpOyB9KTtcbiAgICAgICAgICAgICAgICBzZXJpYWxpemVkW190aGlzLl9ub3JtYWxpemVkTmFtZXMuZ2V0KG5hbWUpXSA9IHNwbGl0O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gc2VyaWFsaXplZDtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgbGlzdCBvZiBoZWFkZXIgdmFsdWVzIGZvciBhIGdpdmVuIG5hbWUuXG4gICAgICAgICAqIEBwYXJhbSB7P30gbmFtZVxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgSGVhZGVycy5wcm90b3R5cGUuZ2V0QWxsID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmhhcyhuYW1lKSA/IHRoaXMuX2hlYWRlcnMuZ2V0KG5hbWUudG9Mb3dlckNhc2UoKSkgOiBudWxsO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyBtZXRob2QgaXMgbm90IGltcGxlbWVudGVkLlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgSGVhZGVycy5wcm90b3R5cGUuZW50cmllcyA9IGZ1bmN0aW9uICgpIHsgdGhyb3cgbmV3IEVycm9yKCdcImVudHJpZXNcIiBtZXRob2QgaXMgbm90IGltcGxlbWVudGVkIG9uIEhlYWRlcnMgY2xhc3MnKTsgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gbmFtZVxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgSGVhZGVycy5wcm90b3R5cGUubWF5QmVTZXROb3JtYWxpemVkTmFtZSA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBsY05hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX25vcm1hbGl6ZWROYW1lcy5oYXMobGNOYW1lKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX25vcm1hbGl6ZWROYW1lcy5zZXQobGNOYW1lLCBuYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIEhlYWRlcnM7XG4gICAgfSgpKTtcblxuICAgIC8qKlxuICAgICAqIEBsaWNlbnNlXG4gICAgICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gICAgICpcbiAgICAgKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICAgICAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAgICAgKi9cbiAgICB2YXIgX19leHRlbmRzJDEgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgcmVzcG9uc2Ugb3B0aW9ucyBvYmplY3QgdG8gYmUgb3B0aW9uYWxseSBwcm92aWRlZCB3aGVuIGluc3RhbnRpYXRpbmcgYVxuICAgICAqIHtcXEBsaW5rIFJlc3BvbnNlfS5cbiAgICAgKlxuICAgICAqIFRoaXMgY2xhc3MgaXMgYmFzZWQgb24gdGhlIGBSZXNwb25zZUluaXRgIGRlc2NyaXB0aW9uIGluIHRoZSBbRmV0Y2hcbiAgICAgKiBTcGVjXShodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jcmVzcG9uc2Vpbml0KS5cbiAgICAgKlxuICAgICAqIEFsbCB2YWx1ZXMgYXJlIG51bGwgYnkgZGVmYXVsdC4gVHlwaWNhbCBkZWZhdWx0cyBjYW4gYmUgZm91bmQgaW4gdGhlXG4gICAgICoge1xcQGxpbmsgQmFzZVJlc3BvbnNlT3B0aW9uc30gY2xhc3MsIHdoaWNoIHN1Yi1jbGFzc2VzIGBSZXNwb25zZU9wdGlvbnNgLlxuICAgICAqXG4gICAgICogVGhpcyBjbGFzcyBtYXkgYmUgdXNlZCBpbiB0ZXN0cyB0byBidWlsZCB7XFxAbGluayBSZXNwb25zZSBSZXNwb25zZXN9IGZvclxuICAgICAqIG1vY2sgcmVzcG9uc2VzIChzZWUge1xcQGxpbmsgTW9ja0JhY2tlbmR9KS5cbiAgICAgKlxuICAgICAqICMjIyBFeGFtcGxlIChbbGl2ZSBkZW1vXShodHRwOi8vcGxua3IuY28vZWRpdC9QOUprazhlOGN6Nk5WemJjeEVzRD9wPXByZXZpZXcpKVxuICAgICAqXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGltcG9ydCB7UmVzcG9uc2VPcHRpb25zLCBSZXNwb25zZX0gZnJvbSAnXFxAYW5ndWxhci9odHRwJztcbiAgICAgKlxuICAgICAqIHZhciBvcHRpb25zID0gbmV3IFJlc3BvbnNlT3B0aW9ucyh7XG4gICAgICogICBib2R5OiAne1wibmFtZVwiOlwiSmVmZlwifSdcbiAgICAgKiB9KTtcbiAgICAgKiB2YXIgcmVzID0gbmV3IFJlc3BvbnNlKG9wdGlvbnMpO1xuICAgICAqXG4gICAgICogY29uc29sZS5sb2coJ3Jlcy5qc29uKCk6JywgcmVzLmpzb24oKSk7IC8vIE9iamVjdCB7bmFtZTogXCJKZWZmXCJ9XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBcXEBleHBlcmltZW50YWxcbiAgICAgKi9cbiAgICB2YXIgUmVzcG9uc2VPcHRpb25zID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7Pz19IF9fMFxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gUmVzcG9uc2VPcHRpb25zKF9hKSB7XG4gICAgICAgICAgICB2YXIgX2IgPSBfYSA9PT0gdm9pZCAwID8ge30gOiBfYSwgYm9keSA9IF9iLmJvZHksIHN0YXR1cyA9IF9iLnN0YXR1cywgaGVhZGVycyA9IF9iLmhlYWRlcnMsIHN0YXR1c1RleHQgPSBfYi5zdGF0dXNUZXh0LCB0eXBlID0gX2IudHlwZSwgdXJsID0gX2IudXJsO1xuICAgICAgICAgICAgdGhpcy5ib2R5ID0gYm9keSAhPSBudWxsID8gYm9keSA6IG51bGw7XG4gICAgICAgICAgICB0aGlzLnN0YXR1cyA9IHN0YXR1cyAhPSBudWxsID8gc3RhdHVzIDogbnVsbDtcbiAgICAgICAgICAgIHRoaXMuaGVhZGVycyA9IGhlYWRlcnMgIT0gbnVsbCA/IGhlYWRlcnMgOiBudWxsO1xuICAgICAgICAgICAgdGhpcy5zdGF0dXNUZXh0ID0gc3RhdHVzVGV4dCAhPSBudWxsID8gc3RhdHVzVGV4dCA6IG51bGw7XG4gICAgICAgICAgICB0aGlzLnR5cGUgPSB0eXBlICE9IG51bGwgPyB0eXBlIDogbnVsbDtcbiAgICAgICAgICAgIHRoaXMudXJsID0gdXJsICE9IG51bGwgPyB1cmwgOiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGEgY29weSBvZiB0aGUgYFJlc3BvbnNlT3B0aW9uc2AgaW5zdGFuY2UsIHVzaW5nIHRoZSBvcHRpb25hbCBpbnB1dCBhcyB2YWx1ZXMgdG9cbiAgICAgICAgICogb3ZlcnJpZGVcbiAgICAgICAgICogZXhpc3RpbmcgdmFsdWVzLiBUaGlzIG1ldGhvZCB3aWxsIG5vdCBjaGFuZ2UgdGhlIHZhbHVlcyBvZiB0aGUgaW5zdGFuY2Ugb24gd2hpY2ggaXQgaXMgYmVpbmdcbiAgICAgICAgICogY2FsbGVkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGlzIG1heSBiZSB1c2VmdWwgd2hlbiBzaGFyaW5nIGEgYmFzZSBgUmVzcG9uc2VPcHRpb25zYCBvYmplY3QgaW5zaWRlIHRlc3RzLFxuICAgICAgICAgKiB3aGVyZSBjZXJ0YWluIHByb3BlcnRpZXMgbWF5IGNoYW5nZSBmcm9tIHRlc3QgdG8gdGVzdC5cbiAgICAgICAgICpcbiAgICAgICAgICogIyMjIEV4YW1wbGUgKFtsaXZlIGRlbW9dKGh0dHA6Ly9wbG5rci5jby9lZGl0LzFsWHF1cUZmZ2R1VEZCV2pOb1JFP3A9cHJldmlldykpXG4gICAgICAgICAqXG4gICAgICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgICAgICogaW1wb3J0IHtSZXNwb25zZU9wdGlvbnMsIFJlc3BvbnNlfSBmcm9tICdcXEBhbmd1bGFyL2h0dHAnO1xuICAgICAgICAgKlxuICAgICAgICAgKiB2YXIgb3B0aW9ucyA9IG5ldyBSZXNwb25zZU9wdGlvbnMoe1xuICAgICAgICAgKiAgIGJvZHk6IHtuYW1lOiAnSmVmZid9XG4gICAgICAgICAqIH0pO1xuICAgICAgICAgKiB2YXIgcmVzID0gbmV3IFJlc3BvbnNlKG9wdGlvbnMubWVyZ2Uoe1xuICAgICAgICAgKiAgIHVybDogJ2h0dHBzOi8vZ29vZ2xlLmNvbSdcbiAgICAgICAgICogfSkpO1xuICAgICAgICAgKiBjb25zb2xlLmxvZygnb3B0aW9ucy51cmw6Jywgb3B0aW9ucy51cmwpOyAvLyBudWxsXG4gICAgICAgICAqIGNvbnNvbGUubG9nKCdyZXMuanNvbigpOicsIHJlcy5qc29uKCkpOyAvLyBPYmplY3Qge25hbWU6IFwiSmVmZlwifVxuICAgICAgICAgKiBjb25zb2xlLmxvZygncmVzLnVybDonLCByZXMudXJsKTsgLy8gaHR0cHM6Ly9nb29nbGUuY29tXG4gICAgICAgICAqIGBgYFxuICAgICAgICAgKiBAcGFyYW0gez89fSBvcHRpb25zXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBSZXNwb25zZU9wdGlvbnMucHJvdG90eXBlLm1lcmdlID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUmVzcG9uc2VPcHRpb25zKHtcbiAgICAgICAgICAgICAgICBib2R5OiBvcHRpb25zICYmIG9wdGlvbnMuYm9keSAhPSBudWxsID8gb3B0aW9ucy5ib2R5IDogdGhpcy5ib2R5LFxuICAgICAgICAgICAgICAgIHN0YXR1czogb3B0aW9ucyAmJiBvcHRpb25zLnN0YXR1cyAhPSBudWxsID8gb3B0aW9ucy5zdGF0dXMgOiB0aGlzLnN0YXR1cyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBvcHRpb25zICYmIG9wdGlvbnMuaGVhZGVycyAhPSBudWxsID8gb3B0aW9ucy5oZWFkZXJzIDogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgICAgIHN0YXR1c1RleHQ6IG9wdGlvbnMgJiYgb3B0aW9ucy5zdGF0dXNUZXh0ICE9IG51bGwgPyBvcHRpb25zLnN0YXR1c1RleHQgOiB0aGlzLnN0YXR1c1RleHQsXG4gICAgICAgICAgICAgICAgdHlwZTogb3B0aW9ucyAmJiBvcHRpb25zLnR5cGUgIT0gbnVsbCA/IG9wdGlvbnMudHlwZSA6IHRoaXMudHlwZSxcbiAgICAgICAgICAgICAgICB1cmw6IG9wdGlvbnMgJiYgb3B0aW9ucy51cmwgIT0gbnVsbCA/IG9wdGlvbnMudXJsIDogdGhpcy51cmwsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIFJlc3BvbnNlT3B0aW9ucztcbiAgICB9KCkpO1xuICAgIC8qKlxuICAgICAqIFN1YmNsYXNzIG9mIHtcXEBsaW5rIFJlc3BvbnNlT3B0aW9uc30sIHdpdGggZGVmYXVsdCB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBEZWZhdWx0IHZhbHVlczpcbiAgICAgKiAgKiBzdGF0dXM6IDIwMFxuICAgICAqICAqIGhlYWRlcnM6IGVtcHR5IHtcXEBsaW5rIEhlYWRlcnN9IG9iamVjdFxuICAgICAqXG4gICAgICogVGhpcyBjbGFzcyBjb3VsZCBiZSBleHRlbmRlZCBhbmQgYm91bmQgdG8gdGhlIHtcXEBsaW5rIFJlc3BvbnNlT3B0aW9uc30gY2xhc3NcbiAgICAgKiB3aGVuIGNvbmZpZ3VyaW5nIGFuIHtcXEBsaW5rIEluamVjdG9yfSwgaW4gb3JkZXIgdG8gb3ZlcnJpZGUgdGhlIGRlZmF1bHQgb3B0aW9uc1xuICAgICAqIHVzZWQgYnkge1xcQGxpbmsgSHR0cH0gdG8gY3JlYXRlIHtcXEBsaW5rIFJlc3BvbnNlIFJlc3BvbnNlc30uXG4gICAgICpcbiAgICAgKiAjIyMgRXhhbXBsZSAoW2xpdmUgZGVtb10oaHR0cDovL3BsbmtyLmNvL2VkaXQvcXY4RExUP3A9cHJldmlldykpXG4gICAgICpcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogaW1wb3J0IHtwcm92aWRlfSBmcm9tICdcXEBhbmd1bGFyL2NvcmUnO1xuICAgICAqIGltcG9ydCB7Ym9vdHN0cmFwfSBmcm9tICdcXEBhbmd1bGFyL3BsYXRmb3JtLWJyb3dzZXIvYnJvd3Nlcic7XG4gICAgICogaW1wb3J0IHtIVFRQX1BST1ZJREVSUywgSGVhZGVycywgSHR0cCwgQmFzZVJlc3BvbnNlT3B0aW9ucywgUmVzcG9uc2VPcHRpb25zfSBmcm9tXG4gICAgICogJ1xcQGFuZ3VsYXIvaHR0cCc7XG4gICAgICogaW1wb3J0IHtBcHB9IGZyb20gJy4vbXlhcHAnO1xuICAgICAqXG4gICAgICogY2xhc3MgTXlPcHRpb25zIGV4dGVuZHMgQmFzZVJlc3BvbnNlT3B0aW9ucyB7XG4gICAgICogICBoZWFkZXJzOkhlYWRlcnMgPSBuZXcgSGVhZGVycyh7bmV0d29yazogJ2dpdGh1Yid9KTtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBib290c3RyYXAoQXBwLCBbSFRUUF9QUk9WSURFUlMsIHtwcm92aWRlOiBSZXNwb25zZU9wdGlvbnMsIHVzZUNsYXNzOiBNeU9wdGlvbnN9XSk7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBUaGUgb3B0aW9ucyBjb3VsZCBhbHNvIGJlIGV4dGVuZGVkIHdoZW4gbWFudWFsbHkgY3JlYXRpbmcgYSB7XFxAbGluayBSZXNwb25zZX1cbiAgICAgKiBvYmplY3QuXG4gICAgICpcbiAgICAgKiAjIyMgRXhhbXBsZSAoW2xpdmUgZGVtb10oaHR0cDovL3BsbmtyLmNvL2VkaXQvVm5nb3NPV2lhRXhFdGJzdERvaXg/cD1wcmV2aWV3KSlcbiAgICAgKlxuICAgICAqIGBgYFxuICAgICAqIGltcG9ydCB7QmFzZVJlc3BvbnNlT3B0aW9ucywgUmVzcG9uc2V9IGZyb20gJ1xcQGFuZ3VsYXIvaHR0cCc7XG4gICAgICpcbiAgICAgKiB2YXIgb3B0aW9ucyA9IG5ldyBCYXNlUmVzcG9uc2VPcHRpb25zKCk7XG4gICAgICogdmFyIHJlcyA9IG5ldyBSZXNwb25zZShvcHRpb25zLm1lcmdlKHtcbiAgICAgKiAgIGJvZHk6ICdBbmd1bGFyJyxcbiAgICAgKiAgIGhlYWRlcnM6IG5ldyBIZWFkZXJzKHtmcmFtZXdvcms6ICdhbmd1bGFyJ30pXG4gICAgICogfSkpO1xuICAgICAqIGNvbnNvbGUubG9nKCdyZXMuaGVhZGVycy5nZXQoXCJmcmFtZXdvcmtcIik6JywgcmVzLmhlYWRlcnMuZ2V0KCdmcmFtZXdvcmsnKSk7IC8vIGFuZ3VsYXJcbiAgICAgKiBjb25zb2xlLmxvZygncmVzLnRleHQoKTonLCByZXMudGV4dCgpKTsgLy8gQW5ndWxhcjtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIFxcQGV4cGVyaW1lbnRhbFxuICAgICAqL1xuICAgIHZhciBCYXNlUmVzcG9uc2VPcHRpb25zID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzJDEoQmFzZVJlc3BvbnNlT3B0aW9ucywgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gQmFzZVJlc3BvbnNlT3B0aW9ucygpIHtcbiAgICAgICAgICAgIF9zdXBlci5jYWxsKHRoaXMsIHsgc3RhdHVzOiAyMDAsIHN0YXR1c1RleHQ6ICdPaycsIHR5cGU6IFJlc3BvbnNlVHlwZS5EZWZhdWx0LCBoZWFkZXJzOiBuZXcgSGVhZGVycygpIH0pO1xuICAgICAgICB9XG4gICAgICAgIEJhc2VSZXNwb25zZU9wdGlvbnMuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5JbmplY3RhYmxlIH0sXG4gICAgICAgIF07XG4gICAgICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgICAgICBCYXNlUmVzcG9uc2VPcHRpb25zLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW107IH07XG4gICAgICAgIHJldHVybiBCYXNlUmVzcG9uc2VPcHRpb25zO1xuICAgIH0oUmVzcG9uc2VPcHRpb25zKSk7XG5cbiAgICAvKipcbiAgICAgKiBAbGljZW5zZVxuICAgICAqIENvcHlyaWdodCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICAgICAqXG4gICAgICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAgICAgKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gICAgICovXG4gICAgLyoqXG4gICAgICogQWJzdHJhY3QgY2xhc3MgZnJvbSB3aGljaCByZWFsIGJhY2tlbmRzIGFyZSBkZXJpdmVkLlxuICAgICAqXG4gICAgICogVGhlIHByaW1hcnkgcHVycG9zZSBvZiBhIGBDb25uZWN0aW9uQmFja2VuZGAgaXMgdG8gY3JlYXRlIG5ldyBjb25uZWN0aW9ucyB0byBmdWxmaWxsIGEgZ2l2ZW5cbiAgICAgKiB7XFxAbGluayBSZXF1ZXN0fS5cbiAgICAgKlxuICAgICAqIFxcQGV4cGVyaW1lbnRhbFxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqL1xuICAgIHZhciBDb25uZWN0aW9uQmFja2VuZCA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIENvbm5lY3Rpb25CYWNrZW5kKCkge1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAYWJzdHJhY3RcbiAgICAgICAgICogQHBhcmFtIHs/fSByZXF1ZXN0XG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBDb25uZWN0aW9uQmFja2VuZC5wcm90b3R5cGUuY3JlYXRlQ29ubmVjdGlvbiA9IGZ1bmN0aW9uIChyZXF1ZXN0KSB7IH07XG4gICAgICAgIHJldHVybiBDb25uZWN0aW9uQmFja2VuZDtcbiAgICB9KCkpO1xuICAgIC8qKlxuICAgICAqIEFic3RyYWN0IGNsYXNzIGZyb20gd2hpY2ggcmVhbCBjb25uZWN0aW9ucyBhcmUgZGVyaXZlZC5cbiAgICAgKlxuICAgICAqIFxcQGV4cGVyaW1lbnRhbFxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqL1xuICAgIHZhciBDb25uZWN0aW9uID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gQ29ubmVjdGlvbigpIHtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQ29ubmVjdGlvbjtcbiAgICB9KCkpO1xuICAgIC8qKlxuICAgICAqIEFuIFhTUkZTdHJhdGVneSBjb25maWd1cmVzIFhTUkYgcHJvdGVjdGlvbiAoZS5nLiB2aWEgaGVhZGVycykgb24gYW4gSFRUUCByZXF1ZXN0LlxuICAgICAqXG4gICAgICogXFxAZXhwZXJpbWVudGFsXG4gICAgICogQGFic3RyYWN0XG4gICAgICovXG4gICAgdmFyIFhTUkZTdHJhdGVneSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIFhTUkZTdHJhdGVneSgpIHtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQGFic3RyYWN0XG4gICAgICAgICAqIEBwYXJhbSB7P30gcmVxXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBYU1JGU3RyYXRlZ3kucHJvdG90eXBlLmNvbmZpZ3VyZVJlcXVlc3QgPSBmdW5jdGlvbiAocmVxKSB7IH07XG4gICAgICAgIHJldHVybiBYU1JGU3RyYXRlZ3k7XG4gICAgfSgpKTtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbWV0aG9kXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBub3JtYWxpemVNZXRob2ROYW1lKG1ldGhvZCkge1xuICAgICAgICBpZiAodHlwZW9mIG1ldGhvZCAhPT0gJ3N0cmluZycpXG4gICAgICAgICAgICByZXR1cm4gbWV0aG9kO1xuICAgICAgICBzd2l0Y2ggKG1ldGhvZC50b1VwcGVyQ2FzZSgpKSB7XG4gICAgICAgICAgICBjYXNlICdHRVQnOlxuICAgICAgICAgICAgICAgIHJldHVybiBSZXF1ZXN0TWV0aG9kLkdldDtcbiAgICAgICAgICAgIGNhc2UgJ1BPU1QnOlxuICAgICAgICAgICAgICAgIHJldHVybiBSZXF1ZXN0TWV0aG9kLlBvc3Q7XG4gICAgICAgICAgICBjYXNlICdQVVQnOlxuICAgICAgICAgICAgICAgIHJldHVybiBSZXF1ZXN0TWV0aG9kLlB1dDtcbiAgICAgICAgICAgIGNhc2UgJ0RFTEVURSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFJlcXVlc3RNZXRob2QuRGVsZXRlO1xuICAgICAgICAgICAgY2FzZSAnT1BUSU9OUyc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFJlcXVlc3RNZXRob2QuT3B0aW9ucztcbiAgICAgICAgICAgIGNhc2UgJ0hFQUQnOlxuICAgICAgICAgICAgICAgIHJldHVybiBSZXF1ZXN0TWV0aG9kLkhlYWQ7XG4gICAgICAgICAgICBjYXNlICdQQVRDSCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFJlcXVlc3RNZXRob2QuUGF0Y2g7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCByZXF1ZXN0IG1ldGhvZC4gVGhlIG1ldGhvZCBcXFwiXCIgKyBtZXRob2QgKyBcIlxcXCIgaXMgbm90IHN1cHBvcnRlZC5cIik7XG4gICAgfVxuICAgIHZhciAvKiogQHR5cGUgez99ICovIGlzU3VjY2VzcyA9IGZ1bmN0aW9uIChzdGF0dXMpIHsgcmV0dXJuIChzdGF0dXMgPj0gMjAwICYmIHN0YXR1cyA8IDMwMCk7IH07XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSB4aHJcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldFJlc3BvbnNlVVJMKHhocikge1xuICAgICAgICBpZiAoJ3Jlc3BvbnNlVVJMJyBpbiB4aHIpIHtcbiAgICAgICAgICAgIHJldHVybiB4aHIucmVzcG9uc2VVUkw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKC9eWC1SZXF1ZXN0LVVSTDovbS50ZXN0KHhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKSkpIHtcbiAgICAgICAgICAgIHJldHVybiB4aHIuZ2V0UmVzcG9uc2VIZWFkZXIoJ1gtUmVxdWVzdC1VUkwnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gaW5wdXRcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHN0cmluZ1RvQXJyYXlCdWZmZXIoaW5wdXQpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gdmlldyA9IG5ldyBVaW50MTZBcnJheShpbnB1dC5sZW5ndGgpO1xuICAgICAgICBmb3IgKHZhciAvKiogQHR5cGUgez99ICovIGkgPSAwLCAvKiogQHR5cGUgez99ICovIHN0ckxlbiA9IGlucHV0Lmxlbmd0aDsgaSA8IHN0ckxlbjsgaSsrKSB7XG4gICAgICAgICAgICB2aWV3W2ldID0gaW5wdXQuY2hhckNvZGVBdChpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmlldy5idWZmZXI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGxpY2Vuc2VcbiAgICAgKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAgICAgKlxuICAgICAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gICAgICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICAgICAqIEBwYXJhbSB7Pz19IHJhd1BhcmFtc1xuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gcGFyYW1QYXJzZXIocmF3UGFyYW1zKSB7XG4gICAgICAgIGlmIChyYXdQYXJhbXMgPT09IHZvaWQgMCkgeyByYXdQYXJhbXMgPSAnJzsgfVxuICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBtYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgIGlmIChyYXdQYXJhbXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcGFyYW1zID0gcmF3UGFyYW1zLnNwbGl0KCcmJyk7XG4gICAgICAgICAgICBwYXJhbXMuZm9yRWFjaChmdW5jdGlvbiAocGFyYW0pIHtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBlcUlkeCA9IHBhcmFtLmluZGV4T2YoJz0nKTtcbiAgICAgICAgICAgICAgICB2YXIgX2EgPSBlcUlkeCA9PSAtMSA/IFtwYXJhbSwgJyddIDogW3BhcmFtLnNsaWNlKDAsIGVxSWR4KSwgcGFyYW0uc2xpY2UoZXFJZHggKyAxKV0sIGtleSA9IF9hWzBdLCB2YWwgPSBfYVsxXTtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBsaXN0ID0gbWFwLmdldChrZXkpIHx8IFtdO1xuICAgICAgICAgICAgICAgIGxpc3QucHVzaCh2YWwpO1xuICAgICAgICAgICAgICAgIG1hcC5zZXQoa2V5LCBsaXN0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYXA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFxcQGV4cGVyaW1lbnRhbFxuICAgICAqXG4gICAgICovXG4gICAgdmFyIFF1ZXJ5RW5jb2RlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIFF1ZXJ5RW5jb2RlcigpIHtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSBrXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBRdWVyeUVuY29kZXIucHJvdG90eXBlLmVuY29kZUtleSA9IGZ1bmN0aW9uIChrKSB7IHJldHVybiBzdGFuZGFyZEVuY29kaW5nKGspOyB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSB2XG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBRdWVyeUVuY29kZXIucHJvdG90eXBlLmVuY29kZVZhbHVlID0gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0YW5kYXJkRW5jb2Rpbmcodik7IH07XG4gICAgICAgIHJldHVybiBRdWVyeUVuY29kZXI7XG4gICAgfSgpKTtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHZcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHN0YW5kYXJkRW5jb2Rpbmcodikge1xuICAgICAgICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KHYpXG4gICAgICAgICAgICAucmVwbGFjZSgvJTQwL2dpLCAnQCcpXG4gICAgICAgICAgICAucmVwbGFjZSgvJTNBL2dpLCAnOicpXG4gICAgICAgICAgICAucmVwbGFjZSgvJTI0L2dpLCAnJCcpXG4gICAgICAgICAgICAucmVwbGFjZSgvJTJDL2dpLCAnLCcpXG4gICAgICAgICAgICAucmVwbGFjZSgvJTNCL2dpLCAnOycpXG4gICAgICAgICAgICAucmVwbGFjZSgvJTJCL2dpLCAnKycpXG4gICAgICAgICAgICAucmVwbGFjZSgvJTNEL2dpLCAnPScpXG4gICAgICAgICAgICAucmVwbGFjZSgvJTNGL2dpLCAnPycpXG4gICAgICAgICAgICAucmVwbGFjZSgvJTJGL2dpLCAnLycpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNYXAtbGlrZSByZXByZXNlbnRhdGlvbiBvZiB1cmwgc2VhcmNoIHBhcmFtZXRlcnMsIGJhc2VkIG9uXG4gICAgICogW1VSTFNlYXJjaFBhcmFtc10oaHR0cHM6Ly91cmwuc3BlYy53aGF0d2cub3JnLyN1cmxzZWFyY2hwYXJhbXMpIGluIHRoZSB1cmwgbGl2aW5nIHN0YW5kYXJkLFxuICAgICAqIHdpdGggc2V2ZXJhbCBleHRlbnNpb25zIGZvciBtZXJnaW5nIFVSTFNlYXJjaFBhcmFtcyBvYmplY3RzOlxuICAgICAqICAgLSBzZXRBbGwoKVxuICAgICAqICAgLSBhcHBlbmRBbGwoKVxuICAgICAqICAgLSByZXBsYWNlQWxsKClcbiAgICAgKlxuICAgICAqIFRoaXMgY2xhc3MgYWNjZXB0cyBhbiBvcHRpb25hbCBzZWNvbmQgcGFyYW1ldGVyIG9mICR7XFxAbGluayBRdWVyeUVuY29kZXJ9LFxuICAgICAqIHdoaWNoIGlzIHVzZWQgdG8gc2VyaWFsaXplIHBhcmFtZXRlcnMgYmVmb3JlIG1ha2luZyBhIHJlcXVlc3QuIEJ5IGRlZmF1bHQsXG4gICAgICogYFF1ZXJ5RW5jb2RlcmAgZW5jb2RlcyBrZXlzIGFuZCB2YWx1ZXMgb2YgcGFyYW1ldGVycyB1c2luZyBgZW5jb2RlVVJJQ29tcG9uZW50YCxcbiAgICAgKiBhbmQgdGhlbiB1bi1lbmNvZGVzIGNlcnRhaW4gY2hhcmFjdGVycyB0aGF0IGFyZSBhbGxvd2VkIHRvIGJlIHBhcnQgb2YgdGhlIHF1ZXJ5XG4gICAgICogYWNjb3JkaW5nIHRvIElFVEYgUkZDIDM5ODY6IGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzOTg2LlxuICAgICAqXG4gICAgICogVGhlc2UgYXJlIHRoZSBjaGFyYWN0ZXJzIHRoYXQgYXJlIG5vdCBlbmNvZGVkOiBgISAkIFxcJyAoICkgKiArICwgOyBBIDkgLSAuIF8gfiA/IC9gXG4gICAgICpcbiAgICAgKiBJZiB0aGUgc2V0IG9mIGFsbG93ZWQgcXVlcnkgY2hhcmFjdGVycyBpcyBub3QgYWNjZXB0YWJsZSBmb3IgYSBwYXJ0aWN1bGFyIGJhY2tlbmQsXG4gICAgICogYFF1ZXJ5RW5jb2RlcmAgY2FuIGJlIHN1YmNsYXNzZWQgYW5kIHByb3ZpZGVkIGFzIHRoZSAybmQgYXJndW1lbnQgdG8gVVJMU2VhcmNoUGFyYW1zLlxuICAgICAqXG4gICAgICogYGBgXG4gICAgICogaW1wb3J0IHtVUkxTZWFyY2hQYXJhbXMsIFF1ZXJ5RW5jb2Rlcn0gZnJvbSAnXFxAYW5ndWxhci9odHRwJztcbiAgICAgKiBjbGFzcyBNeVF1ZXJ5RW5jb2RlciBleHRlbmRzIFF1ZXJ5RW5jb2RlciB7XG4gICAgICogICBlbmNvZGVLZXkoazogc3RyaW5nKTogc3RyaW5nIHtcbiAgICAgKiAgICAgcmV0dXJuIG15RW5jb2RpbmdGdW5jdGlvbihrKTtcbiAgICAgKiAgIH1cbiAgICAgKlxuICAgICAqICAgZW5jb2RlVmFsdWUodjogc3RyaW5nKTogc3RyaW5nIHtcbiAgICAgKiAgICAgcmV0dXJuIG15RW5jb2RpbmdGdW5jdGlvbih2KTtcbiAgICAgKiAgIH1cbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBsZXQgcGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcygnJywgbmV3IE15UXVlcnlFbmNvZGVyKCkpO1xuICAgICAqIGBgYFxuICAgICAqIFxcQGV4cGVyaW1lbnRhbFxuICAgICAqL1xuICAgIHZhciBVUkxTZWFyY2hQYXJhbXMgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/PX0gcmF3UGFyYW1zXG4gICAgICAgICAqIEBwYXJhbSB7Pz19IHF1ZXJ5RW5jb2RlclxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gVVJMU2VhcmNoUGFyYW1zKHJhd1BhcmFtcywgcXVlcnlFbmNvZGVyKSB7XG4gICAgICAgICAgICBpZiAocmF3UGFyYW1zID09PSB2b2lkIDApIHsgcmF3UGFyYW1zID0gJyc7IH1cbiAgICAgICAgICAgIGlmIChxdWVyeUVuY29kZXIgPT09IHZvaWQgMCkgeyBxdWVyeUVuY29kZXIgPSBuZXcgUXVlcnlFbmNvZGVyKCk7IH1cbiAgICAgICAgICAgIHRoaXMucmF3UGFyYW1zID0gcmF3UGFyYW1zO1xuICAgICAgICAgICAgdGhpcy5xdWVyeUVuY29kZXIgPSBxdWVyeUVuY29kZXI7XG4gICAgICAgICAgICB0aGlzLnBhcmFtc01hcCA9IHBhcmFtUGFyc2VyKHJhd1BhcmFtcyk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBVUkxTZWFyY2hQYXJhbXMucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gY2xvbmUgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKCcnLCB0aGlzLnF1ZXJ5RW5jb2Rlcik7XG4gICAgICAgICAgICBjbG9uZS5hcHBlbmRBbGwodGhpcyk7XG4gICAgICAgICAgICByZXR1cm4gY2xvbmU7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IHBhcmFtXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBVUkxTZWFyY2hQYXJhbXMucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uIChwYXJhbSkgeyByZXR1cm4gdGhpcy5wYXJhbXNNYXAuaGFzKHBhcmFtKTsgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gcGFyYW1cbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIFVSTFNlYXJjaFBhcmFtcy5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKHBhcmFtKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBzdG9yZWRQYXJhbSA9IHRoaXMucGFyYW1zTWFwLmdldChwYXJhbSk7XG4gICAgICAgICAgICByZXR1cm4gQXJyYXkuaXNBcnJheShzdG9yZWRQYXJhbSkgPyBzdG9yZWRQYXJhbVswXSA6IG51bGw7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IHBhcmFtXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBVUkxTZWFyY2hQYXJhbXMucHJvdG90eXBlLmdldEFsbCA9IGZ1bmN0aW9uIChwYXJhbSkgeyByZXR1cm4gdGhpcy5wYXJhbXNNYXAuZ2V0KHBhcmFtKSB8fCBbXTsgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gcGFyYW1cbiAgICAgICAgICogQHBhcmFtIHs/fSB2YWxcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIFVSTFNlYXJjaFBhcmFtcy5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKHBhcmFtLCB2YWwpIHtcbiAgICAgICAgICAgIGlmICh2YWwgPT09IHZvaWQgMCB8fCB2YWwgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRlbGV0ZShwYXJhbSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbGlzdCA9IHRoaXMucGFyYW1zTWFwLmdldChwYXJhbSkgfHwgW107XG4gICAgICAgICAgICBsaXN0Lmxlbmd0aCA9IDA7XG4gICAgICAgICAgICBsaXN0LnB1c2godmFsKTtcbiAgICAgICAgICAgIHRoaXMucGFyYW1zTWFwLnNldChwYXJhbSwgbGlzdCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IHNlYXJjaFBhcmFtc1xuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgVVJMU2VhcmNoUGFyYW1zLnByb3RvdHlwZS5zZXRBbGwgPSBmdW5jdGlvbiAoc2VhcmNoUGFyYW1zKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgc2VhcmNoUGFyYW1zLnBhcmFtc01hcC5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSwgcGFyYW0pIHtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBsaXN0ID0gX3RoaXMucGFyYW1zTWFwLmdldChwYXJhbSkgfHwgW107XG4gICAgICAgICAgICAgICAgbGlzdC5sZW5ndGggPSAwO1xuICAgICAgICAgICAgICAgIGxpc3QucHVzaCh2YWx1ZVswXSk7XG4gICAgICAgICAgICAgICAgX3RoaXMucGFyYW1zTWFwLnNldChwYXJhbSwgbGlzdCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gcGFyYW1cbiAgICAgICAgICogQHBhcmFtIHs/fSB2YWxcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIFVSTFNlYXJjaFBhcmFtcy5wcm90b3R5cGUuYXBwZW5kID0gZnVuY3Rpb24gKHBhcmFtLCB2YWwpIHtcbiAgICAgICAgICAgIGlmICh2YWwgPT09IHZvaWQgMCB8fCB2YWwgPT09IG51bGwpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbGlzdCA9IHRoaXMucGFyYW1zTWFwLmdldChwYXJhbSkgfHwgW107XG4gICAgICAgICAgICBsaXN0LnB1c2godmFsKTtcbiAgICAgICAgICAgIHRoaXMucGFyYW1zTWFwLnNldChwYXJhbSwgbGlzdCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IHNlYXJjaFBhcmFtc1xuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgVVJMU2VhcmNoUGFyYW1zLnByb3RvdHlwZS5hcHBlbmRBbGwgPSBmdW5jdGlvbiAoc2VhcmNoUGFyYW1zKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgc2VhcmNoUGFyYW1zLnBhcmFtc01hcC5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSwgcGFyYW0pIHtcbiAgICAgICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBsaXN0ID0gX3RoaXMucGFyYW1zTWFwLmdldChwYXJhbSkgfHwgW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgLyoqIEB0eXBlIHs/fSAqLyBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIGxpc3QucHVzaCh2YWx1ZVtpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF90aGlzLnBhcmFtc01hcC5zZXQocGFyYW0sIGxpc3QpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IHNlYXJjaFBhcmFtc1xuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgVVJMU2VhcmNoUGFyYW1zLnByb3RvdHlwZS5yZXBsYWNlQWxsID0gZnVuY3Rpb24gKHNlYXJjaFBhcmFtcykge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHNlYXJjaFBhcmFtcy5wYXJhbXNNYXAuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUsIHBhcmFtKSB7XG4gICAgICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbGlzdCA9IF90aGlzLnBhcmFtc01hcC5nZXQocGFyYW0pIHx8IFtdO1xuICAgICAgICAgICAgICAgIGxpc3QubGVuZ3RoID0gMDtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciAvKiogQHR5cGUgez99ICovIGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgbGlzdC5wdXNoKHZhbHVlW2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgX3RoaXMucGFyYW1zTWFwLnNldChwYXJhbSwgbGlzdCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBVUkxTZWFyY2hQYXJhbXMucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHBhcmFtc0xpc3QgPSBbXTtcbiAgICAgICAgICAgIHRoaXMucGFyYW1zTWFwLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlcywgaykge1xuICAgICAgICAgICAgICAgIHZhbHVlcy5mb3JFYWNoKGZ1bmN0aW9uICh2KSB7IHJldHVybiBwYXJhbXNMaXN0LnB1c2goX3RoaXMucXVlcnlFbmNvZGVyLmVuY29kZUtleShrKSArICc9JyArIF90aGlzLnF1ZXJ5RW5jb2Rlci5lbmNvZGVWYWx1ZSh2KSk7IH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcGFyYW1zTGlzdC5qb2luKCcmJyk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IHBhcmFtXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBVUkxTZWFyY2hQYXJhbXMucHJvdG90eXBlLmRlbGV0ZSA9IGZ1bmN0aW9uIChwYXJhbSkgeyB0aGlzLnBhcmFtc01hcC5kZWxldGUocGFyYW0pOyB9O1xuICAgICAgICByZXR1cm4gVVJMU2VhcmNoUGFyYW1zO1xuICAgIH0oKSk7XG5cbiAgICAvKipcbiAgICAgKiBIVFRQIHJlcXVlc3QgYm9keSB1c2VkIGJ5IGJvdGgge1xcQGxpbmsgUmVxdWVzdH0gYW5kIHtcXEBsaW5rIFJlc3BvbnNlfVxuICAgICAqIGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNib2R5XG4gICAgICogQGFic3RyYWN0XG4gICAgICovXG4gICAgdmFyIEJvZHkgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBCb2R5KCkge1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBdHRlbXB0cyB0byByZXR1cm4gYm9keSBhcyBwYXJzZWQgYEpTT05gIG9iamVjdCwgb3IgcmFpc2VzIGFuIGV4Y2VwdGlvbi5cbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIEJvZHkucHJvdG90eXBlLmpzb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHRoaXMuX2JvZHkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UoLyoqIEB0eXBlIHs/fSAqLyAodGhpcy5fYm9keSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuX2JvZHkgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBKU09OLnBhcnNlKHRoaXMudGV4dCgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9ib2R5O1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyB0aGUgYm9keSBhcyBhIHN0cmluZywgcHJlc3VtaW5nIGB0b1N0cmluZygpYCBjYW4gYmUgY2FsbGVkIG9uIHRoZSByZXNwb25zZSBib2R5LlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgQm9keS5wcm90b3R5cGUudGV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9ib2R5IGluc3RhbmNlb2YgVVJMU2VhcmNoUGFyYW1zKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2JvZHkudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLl9ib2R5IGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBuZXcgVWludDE2QXJyYXkoLyoqIEB0eXBlIHs/fSAqLyAodGhpcy5fYm9keSkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLl9ib2R5ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIHRoaXMuX2JvZHkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHRoaXMuX2JvZHksIG51bGwsIDIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2JvZHkudG9TdHJpbmcoKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybiB0aGUgYm9keSBhcyBhbiBBcnJheUJ1ZmZlclxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgQm9keS5wcm90b3R5cGUuYXJyYXlCdWZmZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fYm9keSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICh0aGlzLl9ib2R5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzdHJpbmdUb0FycmF5QnVmZmVyKHRoaXMudGV4dCgpKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgdGhlIHJlcXVlc3QncyBib2R5IGFzIGEgQmxvYiwgYXNzdW1pbmcgdGhhdCBib2R5IGV4aXN0cy5cbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIEJvZHkucHJvdG90eXBlLmJsb2IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fYm9keSBpbnN0YW5jZW9mIEJsb2IpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKHRoaXMuX2JvZHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuX2JvZHkgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQmxvYihbdGhpcy5fYm9keV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgcmVxdWVzdCBib2R5IGlzblxcJ3QgZWl0aGVyIGEgYmxvYiBvciBhbiBhcnJheSBidWZmZXInKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIEJvZHk7XG4gICAgfSgpKTtcblxuICAgIC8qKlxuICAgICAqIEBsaWNlbnNlXG4gICAgICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gICAgICpcbiAgICAgKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICAgICAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAgICAgKi9cbiAgICB2YXIgX19leHRlbmRzJDIgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGBSZXNwb25zZWAgaW5zdGFuY2VzIGZyb20gcHJvdmlkZWQgdmFsdWVzLlxuICAgICAqXG4gICAgICogVGhvdWdoIHRoaXMgb2JqZWN0IGlzbid0XG4gICAgICogdXN1YWxseSBpbnN0YW50aWF0ZWQgYnkgZW5kLXVzZXJzLCBpdCBpcyB0aGUgcHJpbWFyeSBvYmplY3QgaW50ZXJhY3RlZCB3aXRoIHdoZW4gaXQgY29tZXMgdGltZSB0b1xuICAgICAqIGFkZCBkYXRhIHRvIGEgdmlldy5cbiAgICAgKlxuICAgICAqICMjIyBFeGFtcGxlXG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKiBodHRwLnJlcXVlc3QoJ215LWZyaWVuZHMudHh0Jykuc3Vic2NyaWJlKHJlc3BvbnNlID0+IHRoaXMuZnJpZW5kcyA9IHJlc3BvbnNlLnRleHQoKSk7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBUaGUgUmVzcG9uc2UncyBpbnRlcmZhY2UgaXMgaW5zcGlyZWQgYnkgdGhlIFJlc3BvbnNlIGNvbnN0cnVjdG9yIGRlZmluZWQgaW4gdGhlIFtGZXRjaFxuICAgICAqIFNwZWNdKGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNyZXNwb25zZS1jbGFzcyksIGJ1dCBpcyBjb25zaWRlcmVkIGEgc3RhdGljIHZhbHVlIHdob3NlIGJvZHlcbiAgICAgKiBjYW4gYmUgYWNjZXNzZWQgbWFueSB0aW1lcy4gVGhlcmUgYXJlIG90aGVyIGRpZmZlcmVuY2VzIGluIHRoZSBpbXBsZW1lbnRhdGlvbiwgYnV0IHRoaXMgaXMgdGhlXG4gICAgICogbW9zdCBzaWduaWZpY2FudC5cbiAgICAgKlxuICAgICAqIFxcQGV4cGVyaW1lbnRhbFxuICAgICAqL1xuICAgIHZhciBSZXNwb25zZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyQyKFJlc3BvbnNlLCBfc3VwZXIpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSByZXNwb25zZU9wdGlvbnNcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIFJlc3BvbnNlKHJlc3BvbnNlT3B0aW9ucykge1xuICAgICAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgICAgICB0aGlzLl9ib2R5ID0gcmVzcG9uc2VPcHRpb25zLmJvZHk7XG4gICAgICAgICAgICB0aGlzLnN0YXR1cyA9IHJlc3BvbnNlT3B0aW9ucy5zdGF0dXM7XG4gICAgICAgICAgICB0aGlzLm9rID0gKHRoaXMuc3RhdHVzID49IDIwMCAmJiB0aGlzLnN0YXR1cyA8PSAyOTkpO1xuICAgICAgICAgICAgdGhpcy5zdGF0dXNUZXh0ID0gcmVzcG9uc2VPcHRpb25zLnN0YXR1c1RleHQ7XG4gICAgICAgICAgICB0aGlzLmhlYWRlcnMgPSByZXNwb25zZU9wdGlvbnMuaGVhZGVycztcbiAgICAgICAgICAgIHRoaXMudHlwZSA9IHJlc3BvbnNlT3B0aW9ucy50eXBlO1xuICAgICAgICAgICAgdGhpcy51cmwgPSByZXNwb25zZU9wdGlvbnMudXJsO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgUmVzcG9uc2UucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIFwiUmVzcG9uc2Ugd2l0aCBzdGF0dXM6IFwiICsgdGhpcy5zdGF0dXMgKyBcIiBcIiArIHRoaXMuc3RhdHVzVGV4dCArIFwiIGZvciBVUkw6IFwiICsgdGhpcy51cmw7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBSZXNwb25zZTtcbiAgICB9KEJvZHkpKTtcblxuICAgIHZhciAvKiogQHR5cGUgez99ICovIF9uZXh0UmVxdWVzdElkID0gMDtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBKU09OUF9IT01FID0gJ19fbmdfanNvbnBfXyc7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gX2pzb25wQ29ubmVjdGlvbnMgPSBudWxsO1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gX2dldEpzb25wQ29ubmVjdGlvbnMoKSB7XG4gICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHcgPSB0eXBlb2Ygd2luZG93ID09ICdvYmplY3QnID8gd2luZG93IDoge307XG4gICAgICAgIGlmIChfanNvbnBDb25uZWN0aW9ucyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgX2pzb25wQ29ubmVjdGlvbnMgPSB3W0pTT05QX0hPTUVdID0ge307XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9qc29ucENvbm5lY3Rpb25zO1xuICAgIH1cbiAgICB2YXIgQnJvd3Nlckpzb25wID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gQnJvd3Nlckpzb25wKCkge1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IHVybFxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgQnJvd3Nlckpzb25wLnByb3RvdHlwZS5idWlsZCA9IGZ1bmN0aW9uICh1cmwpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIG5vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtcbiAgICAgICAgICAgIG5vZGUuc3JjID0gdXJsO1xuICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgQnJvd3Nlckpzb25wLnByb3RvdHlwZS5uZXh0UmVxdWVzdElEID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gXCJfX3JlcVwiICsgX25leHRSZXF1ZXN0SWQrKzsgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gaWRcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIEJyb3dzZXJKc29ucC5wcm90b3R5cGUucmVxdWVzdENhbGxiYWNrID0gZnVuY3Rpb24gKGlkKSB7IHJldHVybiBKU09OUF9IT01FICsgXCIuXCIgKyBpZCArIFwiLmZpbmlzaGVkXCI7IH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IGlkXG4gICAgICAgICAqIEBwYXJhbSB7P30gY29ubmVjdGlvblxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgQnJvd3Nlckpzb25wLnByb3RvdHlwZS5leHBvc2VDb25uZWN0aW9uID0gZnVuY3Rpb24gKGlkLCBjb25uZWN0aW9uKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjb25uZWN0aW9ucyA9IF9nZXRKc29ucENvbm5lY3Rpb25zKCk7XG4gICAgICAgICAgICBjb25uZWN0aW9uc1tpZF0gPSBjb25uZWN0aW9uO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSBpZFxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgQnJvd3Nlckpzb25wLnByb3RvdHlwZS5yZW1vdmVDb25uZWN0aW9uID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgICAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBjb25uZWN0aW9ucyA9IF9nZXRKc29ucENvbm5lY3Rpb25zKCk7XG4gICAgICAgICAgICBjb25uZWN0aW9uc1tpZF0gPSBudWxsO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSBub2RlXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBCcm93c2VySnNvbnAucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbiAobm9kZSkgeyBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKC8qKiBAdHlwZSB7P30gKi8gKChub2RlKSkpOyB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSBub2RlXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBCcm93c2VySnNvbnAucHJvdG90eXBlLmNsZWFudXAgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgaWYgKG5vZGUucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgICAgIG5vZGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCgvKiogQHR5cGUgez99ICovICgobm9kZSkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgQnJvd3Nlckpzb25wLmRlY29yYXRvcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5qZWN0YWJsZSB9LFxuICAgICAgICBdO1xuICAgICAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICAgICAgQnJvd3Nlckpzb25wLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW107IH07XG4gICAgICAgIHJldHVybiBCcm93c2VySnNvbnA7XG4gICAgfSgpKTtcblxuICAgIC8qKlxuICAgICAqIEBsaWNlbnNlXG4gICAgICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gICAgICpcbiAgICAgKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICAgICAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAgICAgKi9cbiAgICB2YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gSlNPTlBfRVJSX05PX0NBTExCQUNLID0gJ0pTT05QIGluamVjdGVkIHNjcmlwdCBkaWQgbm90IGludm9rZSBjYWxsYmFjay4nO1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIEpTT05QX0VSUl9XUk9OR19NRVRIT0QgPSAnSlNPTlAgcmVxdWVzdHMgbXVzdCB1c2UgR0VUIHJlcXVlc3QgbWV0aG9kLic7XG4gICAgLyoqXG4gICAgICogQWJzdHJhY3QgYmFzZSBjbGFzcyBmb3IgYW4gaW4tZmxpZ2h0IEpTT05QIHJlcXVlc3QuXG4gICAgICpcbiAgICAgKiBcXEBleHBlcmltZW50YWxcbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKi9cbiAgICB2YXIgSlNPTlBDb25uZWN0aW9uID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gSlNPTlBDb25uZWN0aW9uKCkge1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDYWxsYmFjayBjYWxsZWQgd2hlbiB0aGUgSlNPTlAgcmVxdWVzdCBjb21wbGV0ZXMsIHRvIG5vdGlmeSB0aGUgYXBwbGljYXRpb25cbiAgICAgICAgICogb2YgdGhlIG5ldyBkYXRhLlxuICAgICAgICAgKiBAYWJzdHJhY3RcbiAgICAgICAgICogQHBhcmFtIHs/PX0gZGF0YVxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgSlNPTlBDb25uZWN0aW9uLnByb3RvdHlwZS5maW5pc2hlZCA9IGZ1bmN0aW9uIChkYXRhKSB7IH07XG4gICAgICAgIHJldHVybiBKU09OUENvbm5lY3Rpb247XG4gICAgfSgpKTtcbiAgICB2YXIgSlNPTlBDb25uZWN0aW9uXyA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyhKU09OUENvbm5lY3Rpb25fLCBfc3VwZXIpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSByZXFcbiAgICAgICAgICogQHBhcmFtIHs/fSBfZG9tXG4gICAgICAgICAqIEBwYXJhbSB7Pz19IGJhc2VSZXNwb25zZU9wdGlvbnNcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIEpTT05QQ29ubmVjdGlvbl8ocmVxLCBfZG9tLCBiYXNlUmVzcG9uc2VPcHRpb25zKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgICAgICB0aGlzLl9kb20gPSBfZG9tO1xuICAgICAgICAgICAgdGhpcy5iYXNlUmVzcG9uc2VPcHRpb25zID0gYmFzZVJlc3BvbnNlT3B0aW9ucztcbiAgICAgICAgICAgIHRoaXMuX2ZpbmlzaGVkID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAocmVxLm1ldGhvZCAhPT0gUmVxdWVzdE1ldGhvZC5HZXQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEpTT05QX0VSUl9XUk9OR19NRVRIT0QpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5yZXF1ZXN0ID0gcmVxO1xuICAgICAgICAgICAgdGhpcy5yZXNwb25zZSA9IG5ldyByeGpzX09ic2VydmFibGUuT2JzZXJ2YWJsZShmdW5jdGlvbiAocmVzcG9uc2VPYnNlcnZlcikge1xuICAgICAgICAgICAgICAgIF90aGlzLnJlYWR5U3RhdGUgPSBSZWFkeVN0YXRlLkxvYWRpbmc7XG4gICAgICAgICAgICAgICAgdmFyIGlkID0gX3RoaXMuX2lkID0gX2RvbS5uZXh0UmVxdWVzdElEKCk7XG4gICAgICAgICAgICAgICAgX2RvbS5leHBvc2VDb25uZWN0aW9uKGlkLCBfdGhpcyk7XG4gICAgICAgICAgICAgICAgLy8gV29ya2Fyb3VuZCBEYXJ0XG4gICAgICAgICAgICAgICAgLy8gdXJsID0gdXJsLnJlcGxhY2UoLz1KU09OUF9DQUxMQkFDSygmfCQpLywgYGdlbmVyYXRlZCBtZXRob2RgKTtcbiAgICAgICAgICAgICAgICB2YXIgY2FsbGJhY2sgPSBfZG9tLnJlcXVlc3RDYWxsYmFjayhfdGhpcy5faWQpO1xuICAgICAgICAgICAgICAgIHZhciB1cmwgPSByZXEudXJsO1xuICAgICAgICAgICAgICAgIGlmICh1cmwuaW5kZXhPZignPUpTT05QX0NBTExCQUNLJicpID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgdXJsID0gdXJsLnJlcGxhY2UoJz1KU09OUF9DQUxMQkFDSyYnLCBcIj1cIiArIGNhbGxiYWNrICsgXCImXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh1cmwubGFzdEluZGV4T2YoJz1KU09OUF9DQUxMQkFDSycpID09PSB1cmwubGVuZ3RoIC0gJz1KU09OUF9DQUxMQkFDSycubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHVybCA9IHVybC5zdWJzdHJpbmcoMCwgdXJsLmxlbmd0aCAtICc9SlNPTlBfQ0FMTEJBQ0snLmxlbmd0aCkgKyAoXCI9XCIgKyBjYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBzY3JpcHQgPSBfdGhpcy5fc2NyaXB0ID0gX2RvbS5idWlsZCh1cmwpO1xuICAgICAgICAgICAgICAgIHZhciBvbkxvYWQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzLnJlYWR5U3RhdGUgPT09IFJlYWR5U3RhdGUuQ2FuY2VsbGVkKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5yZWFkeVN0YXRlID0gUmVhZHlTdGF0ZS5Eb25lO1xuICAgICAgICAgICAgICAgICAgICBfZG9tLmNsZWFudXAoc2NyaXB0KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFfdGhpcy5fZmluaXNoZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXNwb25zZU9wdGlvbnNfMSA9IG5ldyBSZXNwb25zZU9wdGlvbnMoeyBib2R5OiBKU09OUF9FUlJfTk9fQ0FMTEJBQ0ssIHR5cGU6IFJlc3BvbnNlVHlwZS5FcnJvciwgdXJsOiB1cmwgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYmFzZVJlc3BvbnNlT3B0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlT3B0aW9uc18xID0gYmFzZVJlc3BvbnNlT3B0aW9ucy5tZXJnZShyZXNwb25zZU9wdGlvbnNfMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZU9ic2VydmVyLmVycm9yKG5ldyBSZXNwb25zZShyZXNwb25zZU9wdGlvbnNfMSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciByZXNwb25zZU9wdGlvbnMgPSBuZXcgUmVzcG9uc2VPcHRpb25zKHsgYm9keTogX3RoaXMuX3Jlc3BvbnNlRGF0YSwgdXJsOiB1cmwgfSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChfdGhpcy5iYXNlUmVzcG9uc2VPcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZU9wdGlvbnMgPSBfdGhpcy5iYXNlUmVzcG9uc2VPcHRpb25zLm1lcmdlKHJlc3BvbnNlT3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2VPYnNlcnZlci5uZXh0KG5ldyBSZXNwb25zZShyZXNwb25zZU9wdGlvbnMpKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2VPYnNlcnZlci5jb21wbGV0ZSgpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdmFyIG9uRXJyb3IgPSBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzLnJlYWR5U3RhdGUgPT09IFJlYWR5U3RhdGUuQ2FuY2VsbGVkKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5yZWFkeVN0YXRlID0gUmVhZHlTdGF0ZS5Eb25lO1xuICAgICAgICAgICAgICAgICAgICBfZG9tLmNsZWFudXAoc2NyaXB0KTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3BvbnNlT3B0aW9ucyA9IG5ldyBSZXNwb25zZU9wdGlvbnMoeyBib2R5OiBlcnJvci5tZXNzYWdlLCB0eXBlOiBSZXNwb25zZVR5cGUuRXJyb3IgfSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChiYXNlUmVzcG9uc2VPcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZU9wdGlvbnMgPSBiYXNlUmVzcG9uc2VPcHRpb25zLm1lcmdlKHJlc3BvbnNlT3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2VPYnNlcnZlci5lcnJvcihuZXcgUmVzcG9uc2UocmVzcG9uc2VPcHRpb25zKSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBzY3JpcHQuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsIG9uTG9hZCk7XG4gICAgICAgICAgICAgICAgc2NyaXB0LmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgb25FcnJvcik7XG4gICAgICAgICAgICAgICAgX2RvbS5zZW5kKHNjcmlwdCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMucmVhZHlTdGF0ZSA9IFJlYWR5U3RhdGUuQ2FuY2VsbGVkO1xuICAgICAgICAgICAgICAgICAgICBzY3JpcHQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbG9hZCcsIG9uTG9hZCk7XG4gICAgICAgICAgICAgICAgICAgIHNjcmlwdC5yZW1vdmVFdmVudExpc3RlbmVyKCdlcnJvcicsIG9uRXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fZG9tLmNsZWFudXAoc2NyaXB0KTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7Pz19IGRhdGFcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIEpTT05QQ29ubmVjdGlvbl8ucHJvdG90eXBlLmZpbmlzaGVkID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgIC8vIERvbid0IGxlYWsgY29ubmVjdGlvbnNcbiAgICAgICAgICAgIHRoaXMuX2ZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX2RvbS5yZW1vdmVDb25uZWN0aW9uKHRoaXMuX2lkKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgPT09IFJlYWR5U3RhdGUuQ2FuY2VsbGVkKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHRoaXMuX3Jlc3BvbnNlRGF0YSA9IGRhdGE7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBKU09OUENvbm5lY3Rpb25fO1xuICAgIH0oSlNPTlBDb25uZWN0aW9uKSk7XG4gICAgLyoqXG4gICAgICogQSB7XFxAbGluayBDb25uZWN0aW9uQmFja2VuZH0gdGhhdCB1c2VzIHRoZSBKU09OUCBzdHJhdGVneSBvZiBtYWtpbmcgcmVxdWVzdHMuXG4gICAgICpcbiAgICAgKiBcXEBleHBlcmltZW50YWxcbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKi9cbiAgICB2YXIgSlNPTlBCYWNrZW5kID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzKEpTT05QQmFja2VuZCwgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gSlNPTlBCYWNrZW5kKCkge1xuICAgICAgICAgICAgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEpTT05QQmFja2VuZDtcbiAgICB9KENvbm5lY3Rpb25CYWNrZW5kKSk7XG4gICAgdmFyIEpTT05QQmFja2VuZF8gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMoSlNPTlBCYWNrZW5kXywgX3N1cGVyKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gX2Jyb3dzZXJKU09OUFxuICAgICAgICAgKiBAcGFyYW0gez99IF9iYXNlUmVzcG9uc2VPcHRpb25zXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBKU09OUEJhY2tlbmRfKF9icm93c2VySlNPTlAsIF9iYXNlUmVzcG9uc2VPcHRpb25zKSB7XG4gICAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuX2Jyb3dzZXJKU09OUCA9IF9icm93c2VySlNPTlA7XG4gICAgICAgICAgICB0aGlzLl9iYXNlUmVzcG9uc2VPcHRpb25zID0gX2Jhc2VSZXNwb25zZU9wdGlvbnM7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gcmVxdWVzdFxuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgSlNPTlBCYWNrZW5kXy5wcm90b3R5cGUuY3JlYXRlQ29ubmVjdGlvbiA9IGZ1bmN0aW9uIChyZXF1ZXN0KSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEpTT05QQ29ubmVjdGlvbl8ocmVxdWVzdCwgdGhpcy5fYnJvd3NlckpTT05QLCB0aGlzLl9iYXNlUmVzcG9uc2VPcHRpb25zKTtcbiAgICAgICAgfTtcbiAgICAgICAgSlNPTlBCYWNrZW5kXy5kZWNvcmF0b3JzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkluamVjdGFibGUgfSxcbiAgICAgICAgXTtcbiAgICAgICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgICAgIEpTT05QQmFja2VuZF8uY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgICAgICAgICB7IHR5cGU6IEJyb3dzZXJKc29ucCwgfSxcbiAgICAgICAgICAgIHsgdHlwZTogUmVzcG9uc2VPcHRpb25zLCB9LFxuICAgICAgICBdOyB9O1xuICAgICAgICByZXR1cm4gSlNPTlBCYWNrZW5kXztcbiAgICB9KEpTT05QQmFja2VuZCkpO1xuXG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gWFNTSV9QUkVGSVggPSAvXlxcKVxcXVxcfScsP1xcbi87XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBjb25uZWN0aW9ucyB1c2luZyBgWE1MSHR0cFJlcXVlc3RgLiBHaXZlbiBhIGZ1bGx5LXF1YWxpZmllZFxuICAgICAqIHJlcXVlc3QsIGFuIGBYSFJDb25uZWN0aW9uYCB3aWxsIGltbWVkaWF0ZWx5IGNyZWF0ZSBhbiBgWE1MSHR0cFJlcXVlc3RgIG9iamVjdCBhbmQgc2VuZCB0aGVcbiAgICAgKiByZXF1ZXN0LlxuICAgICAqXG4gICAgICogVGhpcyBjbGFzcyB3b3VsZCB0eXBpY2FsbHkgbm90IGJlIGNyZWF0ZWQgb3IgaW50ZXJhY3RlZCB3aXRoIGRpcmVjdGx5IGluc2lkZSBhcHBsaWNhdGlvbnMsIHRob3VnaFxuICAgICAqIHRoZSB7XFxAbGluayBNb2NrQ29ubmVjdGlvbn0gbWF5IGJlIGludGVyYWN0ZWQgd2l0aCBpbiB0ZXN0cy5cbiAgICAgKlxuICAgICAqIFxcQGV4cGVyaW1lbnRhbFxuICAgICAqL1xuICAgIHZhciBYSFJDb25uZWN0aW9uID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gcmVxXG4gICAgICAgICAqIEBwYXJhbSB7P30gYnJvd3NlclhIUlxuICAgICAgICAgKiBAcGFyYW0gez89fSBiYXNlUmVzcG9uc2VPcHRpb25zXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBYSFJDb25uZWN0aW9uKHJlcSwgYnJvd3NlclhIUiwgYmFzZVJlc3BvbnNlT3B0aW9ucykge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHRoaXMucmVxdWVzdCA9IHJlcTtcbiAgICAgICAgICAgIHRoaXMucmVzcG9uc2UgPSBuZXcgcnhqc19PYnNlcnZhYmxlLk9ic2VydmFibGUoZnVuY3Rpb24gKHJlc3BvbnNlT2JzZXJ2ZXIpIHtcbiAgICAgICAgICAgICAgICB2YXIgX3hociA9IGJyb3dzZXJYSFIuYnVpbGQoKTtcbiAgICAgICAgICAgICAgICBfeGhyLm9wZW4oUmVxdWVzdE1ldGhvZFtyZXEubWV0aG9kXS50b1VwcGVyQ2FzZSgpLCByZXEudXJsKTtcbiAgICAgICAgICAgICAgICBpZiAocmVxLndpdGhDcmVkZW50aWFscyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIF94aHIud2l0aENyZWRlbnRpYWxzID0gcmVxLndpdGhDcmVkZW50aWFscztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gbG9hZCBldmVudCBoYW5kbGVyXG4gICAgICAgICAgICAgICAgdmFyIG9uTG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gbm9ybWFsaXplIElFOSBidWcgKGh0dHA6Ly9idWdzLmpxdWVyeS5jb20vdGlja2V0LzE0NTApXG4gICAgICAgICAgICAgICAgICAgIHZhciBzdGF0dXMgPSBfeGhyLnN0YXR1cyA9PT0gMTIyMyA/IDIwNCA6IF94aHIuc3RhdHVzO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYm9keSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIC8vIEhUVFAgMjA0IG1lYW5zIG5vIGNvbnRlbnRcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXR1cyAhPT0gMjA0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyByZXNwb25zZVRleHQgaXMgdGhlIG9sZC1zY2hvb2wgd2F5IG9mIHJldHJpZXZpbmcgcmVzcG9uc2UgKHN1cHBvcnRlZCBieSBJRTggJiA5KVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVzcG9uc2UvcmVzcG9uc2VUeXBlIHByb3BlcnRpZXMgd2VyZSBpbnRyb2R1Y2VkIGluIFJlc291cmNlTG9hZGVyIExldmVsMiBzcGVjXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAoc3VwcG9ydGVkIGJ5IElFMTApXG4gICAgICAgICAgICAgICAgICAgICAgICBib2R5ID0gKHR5cGVvZiBfeGhyLnJlc3BvbnNlID09PSAndW5kZWZpbmVkJykgPyBfeGhyLnJlc3BvbnNlVGV4dCA6IF94aHIucmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJbXBsaWNpdGx5IHN0cmlwIGEgcG90ZW50aWFsIFhTU0kgcHJlZml4LlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBib2R5ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvZHkgPSBib2R5LnJlcGxhY2UoWFNTSV9QUkVGSVgsICcnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBmaXggc3RhdHVzIGNvZGUgd2hlbiBpdCBpcyAwICgwIHN0YXR1cyBpcyB1bmRvY3VtZW50ZWQpLlxuICAgICAgICAgICAgICAgICAgICAvLyBPY2N1cnMgd2hlbiBhY2Nlc3NpbmcgZmlsZSByZXNvdXJjZXMgb3Igb24gQW5kcm9pZCA0LjEgc3RvY2sgYnJvd3NlclxuICAgICAgICAgICAgICAgICAgICAvLyB3aGlsZSByZXRyaWV2aW5nIGZpbGVzIGZyb20gYXBwbGljYXRpb24gY2FjaGUuXG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGF0dXMgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1cyA9IGJvZHkgPyAyMDAgOiAwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciBoZWFkZXJzID0gSGVhZGVycy5mcm9tUmVzcG9uc2VIZWFkZXJTdHJpbmcoX3hoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIElFIDkgZG9lcyBub3QgcHJvdmlkZSB0aGUgd2F5IHRvIGdldCBVUkwgb2YgcmVzcG9uc2VcbiAgICAgICAgICAgICAgICAgICAgdmFyIHVybCA9IGdldFJlc3BvbnNlVVJMKF94aHIpIHx8IHJlcS51cmw7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzdGF0dXNUZXh0ID0gX3hoci5zdGF0dXNUZXh0IHx8ICdPSyc7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZXNwb25zZU9wdGlvbnMgPSBuZXcgUmVzcG9uc2VPcHRpb25zKHsgYm9keTogYm9keSwgc3RhdHVzOiBzdGF0dXMsIGhlYWRlcnM6IGhlYWRlcnMsIHN0YXR1c1RleHQ6IHN0YXR1c1RleHQsIHVybDogdXJsIH0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYmFzZVJlc3BvbnNlT3B0aW9ucyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZU9wdGlvbnMgPSBiYXNlUmVzcG9uc2VPcHRpb25zLm1lcmdlKHJlc3BvbnNlT3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3BvbnNlID0gbmV3IFJlc3BvbnNlKHJlc3BvbnNlT3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLm9rID0gaXNTdWNjZXNzKHN0YXR1cyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZS5vaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2VPYnNlcnZlci5uZXh0KHJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE8oZ2RpMjI5MCk6IGRlZmVyIGNvbXBsZXRlIGlmIGFycmF5IGJ1ZmZlciB1bnRpbCBkb25lXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZU9ic2VydmVyLmNvbXBsZXRlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2VPYnNlcnZlci5lcnJvcihyZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAvLyBlcnJvciBldmVudCBoYW5kbGVyXG4gICAgICAgICAgICAgICAgdmFyIG9uRXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZXNwb25zZU9wdGlvbnMgPSBuZXcgUmVzcG9uc2VPcHRpb25zKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvZHk6IGVycixcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFJlc3BvbnNlVHlwZS5FcnJvcixcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1czogX3hoci5zdGF0dXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXNUZXh0OiBfeGhyLnN0YXR1c1RleHQsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYmFzZVJlc3BvbnNlT3B0aW9ucyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZU9wdGlvbnMgPSBiYXNlUmVzcG9uc2VPcHRpb25zLm1lcmdlKHJlc3BvbnNlT3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2VPYnNlcnZlci5lcnJvcihuZXcgUmVzcG9uc2UocmVzcG9uc2VPcHRpb25zKSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBfdGhpcy5zZXREZXRlY3RlZENvbnRlbnRUeXBlKHJlcSwgX3hocik7XG4gICAgICAgICAgICAgICAgaWYgKHJlcS5oZWFkZXJzID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVxLmhlYWRlcnMgPSBuZXcgSGVhZGVycygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIXJlcS5oZWFkZXJzLmhhcygnQWNjZXB0JykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVxLmhlYWRlcnMuYXBwZW5kKCdBY2NlcHQnLCAnYXBwbGljYXRpb24vanNvbiwgdGV4dC9wbGFpbiwgKi8qJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlcS5oZWFkZXJzLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlcywgbmFtZSkgeyByZXR1cm4gX3hoci5zZXRSZXF1ZXN0SGVhZGVyKG5hbWUsIHZhbHVlcy5qb2luKCcsJykpOyB9KTtcbiAgICAgICAgICAgICAgICAvLyBTZWxlY3QgdGhlIGNvcnJlY3QgYnVmZmVyIHR5cGUgdG8gc3RvcmUgdGhlIHJlc3BvbnNlXG4gICAgICAgICAgICAgICAgaWYgKHJlcS5yZXNwb25zZVR5cGUgIT0gbnVsbCAmJiBfeGhyLnJlc3BvbnNlVHlwZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAocmVxLnJlc3BvbnNlVHlwZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBSZXNwb25zZUNvbnRlbnRUeXBlLkFycmF5QnVmZmVyOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF94aHIucmVzcG9uc2VUeXBlID0gJ2FycmF5YnVmZmVyJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgUmVzcG9uc2VDb250ZW50VHlwZS5Kc29uOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF94aHIucmVzcG9uc2VUeXBlID0gJ2pzb24nO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBSZXNwb25zZUNvbnRlbnRUeXBlLlRleHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3hoci5yZXNwb25zZVR5cGUgPSAndGV4dCc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFJlc3BvbnNlQ29udGVudFR5cGUuQmxvYjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfeGhyLnJlc3BvbnNlVHlwZSA9ICdibG9iJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgc2VsZWN0ZWQgcmVzcG9uc2VUeXBlIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBfeGhyLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCBvbkxvYWQpO1xuICAgICAgICAgICAgICAgIF94aHIuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCBvbkVycm9yKTtcbiAgICAgICAgICAgICAgICBfeGhyLnNlbmQoX3RoaXMucmVxdWVzdC5nZXRCb2R5KCkpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIF94aHIucmVtb3ZlRXZlbnRMaXN0ZW5lcignbG9hZCcsIG9uTG9hZCk7XG4gICAgICAgICAgICAgICAgICAgIF94aHIucmVtb3ZlRXZlbnRMaXN0ZW5lcignZXJyb3InLCBvbkVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgX3hoci5hYm9ydCgpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSByZXFcbiAgICAgICAgICogQHBhcmFtIHs/fSBfeGhyXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBYSFJDb25uZWN0aW9uLnByb3RvdHlwZS5zZXREZXRlY3RlZENvbnRlbnRUeXBlID0gZnVuY3Rpb24gKHJlcSAvKiogVE9ETyBSZXF1ZXN0ICovLCBfeGhyIC8qKiBYTUxIdHRwUmVxdWVzdCAqLykge1xuICAgICAgICAgICAgLy8gU2tpcCBpZiBhIGN1c3RvbSBDb250ZW50LVR5cGUgaGVhZGVyIGlzIHByb3ZpZGVkXG4gICAgICAgICAgICBpZiAocmVxLmhlYWRlcnMgIT0gbnVsbCAmJiByZXEuaGVhZGVycy5nZXQoJ0NvbnRlbnQtVHlwZScpICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTZXQgdGhlIGRldGVjdGVkIGNvbnRlbnQgdHlwZVxuICAgICAgICAgICAgc3dpdGNoIChyZXEuY29udGVudFR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIENvbnRlbnRUeXBlLk5PTkU6XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgQ29udGVudFR5cGUuSlNPTjpcbiAgICAgICAgICAgICAgICAgICAgX3hoci5zZXRSZXF1ZXN0SGVhZGVyKCdjb250ZW50LXR5cGUnLCAnYXBwbGljYXRpb24vanNvbicpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIENvbnRlbnRUeXBlLkZPUk06XG4gICAgICAgICAgICAgICAgICAgIF94aHIuc2V0UmVxdWVzdEhlYWRlcignY29udGVudC10eXBlJywgJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZDtjaGFyc2V0PVVURi04Jyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgQ29udGVudFR5cGUuVEVYVDpcbiAgICAgICAgICAgICAgICAgICAgX3hoci5zZXRSZXF1ZXN0SGVhZGVyKCdjb250ZW50LXR5cGUnLCAndGV4dC9wbGFpbicpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIENvbnRlbnRUeXBlLkJMT0I6XG4gICAgICAgICAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIGJsb2IgPSByZXEuYmxvYigpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYmxvYi50eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfeGhyLnNldFJlcXVlc3RIZWFkZXIoJ2NvbnRlbnQtdHlwZScsIGJsb2IudHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBYSFJDb25uZWN0aW9uO1xuICAgIH0oKSk7XG4gICAgLyoqXG4gICAgICogYFhTUkZDb25maWd1cmF0aW9uYCBzZXRzIHVwIENyb3NzIFNpdGUgUmVxdWVzdCBGb3JnZXJ5IChYU1JGKSBwcm90ZWN0aW9uIGZvciB0aGUgYXBwbGljYXRpb25cbiAgICAgKiB1c2luZyBhIGNvb2tpZS4gU2VlIGh0dHBzOi8vd3d3Lm93YXNwLm9yZy9pbmRleC5waHAvQ3Jvc3MtU2l0ZV9SZXF1ZXN0X0ZvcmdlcnlfKENTUkYpXG4gICAgICogZm9yIG1vcmUgaW5mb3JtYXRpb24gb24gWFNSRi5cbiAgICAgKlxuICAgICAqIEFwcGxpY2F0aW9ucyBjYW4gY29uZmlndXJlIGN1c3RvbSBjb29raWUgYW5kIGhlYWRlciBuYW1lcyBieSBiaW5kaW5nIGFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3NcbiAgICAgKiB3aXRoIGRpZmZlcmVudCBgY29va2llTmFtZWAgYW5kIGBoZWFkZXJOYW1lYCB2YWx1ZXMuIFNlZSB0aGUgbWFpbiBIVFRQIGRvY3VtZW50YXRpb24gZm9yIG1vcmVcbiAgICAgKiBkZXRhaWxzLlxuICAgICAqXG4gICAgICogXFxAZXhwZXJpbWVudGFsXG4gICAgICovXG4gICAgdmFyIENvb2tpZVhTUkZTdHJhdGVneSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez89fSBfY29va2llTmFtZVxuICAgICAgICAgKiBAcGFyYW0gez89fSBfaGVhZGVyTmFtZVxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gQ29va2llWFNSRlN0cmF0ZWd5KF9jb29raWVOYW1lLCBfaGVhZGVyTmFtZSkge1xuICAgICAgICAgICAgaWYgKF9jb29raWVOYW1lID09PSB2b2lkIDApIHsgX2Nvb2tpZU5hbWUgPSAnWFNSRi1UT0tFTic7IH1cbiAgICAgICAgICAgIGlmIChfaGVhZGVyTmFtZSA9PT0gdm9pZCAwKSB7IF9oZWFkZXJOYW1lID0gJ1gtWFNSRi1UT0tFTic7IH1cbiAgICAgICAgICAgIHRoaXMuX2Nvb2tpZU5hbWUgPSBfY29va2llTmFtZTtcbiAgICAgICAgICAgIHRoaXMuX2hlYWRlck5hbWUgPSBfaGVhZGVyTmFtZTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSByZXFcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIENvb2tpZVhTUkZTdHJhdGVneS5wcm90b3R5cGUuY29uZmlndXJlUmVxdWVzdCA9IGZ1bmN0aW9uIChyZXEpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHhzcmZUb2tlbiA9IF9hbmd1bGFyX3BsYXRmb3JtQnJvd3Nlci5fX3BsYXRmb3JtX2Jyb3dzZXJfcHJpdmF0ZV9fLmdldERPTSgpLmdldENvb2tpZSh0aGlzLl9jb29raWVOYW1lKTtcbiAgICAgICAgICAgIGlmICh4c3JmVG9rZW4pIHtcbiAgICAgICAgICAgICAgICByZXEuaGVhZGVycy5zZXQodGhpcy5faGVhZGVyTmFtZSwgeHNyZlRva2VuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIENvb2tpZVhTUkZTdHJhdGVneTtcbiAgICB9KCkpO1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMge1xcQGxpbmsgWEhSQ29ubmVjdGlvbn0gaW5zdGFuY2VzLlxuICAgICAqXG4gICAgICogVGhpcyBjbGFzcyB3b3VsZCB0eXBpY2FsbHkgbm90IGJlIHVzZWQgYnkgZW5kIHVzZXJzLCBidXQgY291bGQgYmVcbiAgICAgKiBvdmVycmlkZGVuIGlmIGEgZGlmZmVyZW50IGJhY2tlbmQgaW1wbGVtZW50YXRpb24gc2hvdWxkIGJlIHVzZWQsXG4gICAgICogc3VjaCBhcyBpbiBhIG5vZGUgYmFja2VuZC5cbiAgICAgKlxuICAgICAqICMjIyBFeGFtcGxlXG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKiBpbXBvcnQge0h0dHAsIE15Tm9kZUJhY2tlbmQsIEhUVFBfUFJPVklERVJTLCBCYXNlUmVxdWVzdE9wdGlvbnN9IGZyb20gJ1xcQGFuZ3VsYXIvaHR0cCc7XG4gICAgICogXFxAQ29tcG9uZW50KHtcbiAgICAgKiAgIHZpZXdQcm92aWRlcnM6IFtcbiAgICAgKiAgICAgSFRUUF9QUk9WSURFUlMsXG4gICAgICogICAgIHtwcm92aWRlOiBIdHRwLCB1c2VGYWN0b3J5OiAoYmFja2VuZCwgb3B0aW9ucykgPT4ge1xuICAgICAqICAgICAgIHJldHVybiBuZXcgSHR0cChiYWNrZW5kLCBvcHRpb25zKTtcbiAgICAgKiAgICAgfSwgZGVwczogW015Tm9kZUJhY2tlbmQsIEJhc2VSZXF1ZXN0T3B0aW9uc119XVxuICAgICAqIH0pXG4gICAgICogY2xhc3MgTXlDb21wb25lbnQge1xuICAgICAqICAgY29uc3RydWN0b3IoaHR0cDpIdHRwKSB7XG4gICAgICogICAgIGh0dHAucmVxdWVzdCgncGVvcGxlLmpzb24nKS5zdWJzY3JpYmUocmVzID0+IHRoaXMucGVvcGxlID0gcmVzLmpzb24oKSk7XG4gICAgICogICB9XG4gICAgICogfVxuICAgICAqIGBgYFxuICAgICAqIFxcQGV4cGVyaW1lbnRhbFxuICAgICAqL1xuICAgIHZhciBYSFJCYWNrZW5kID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gX2Jyb3dzZXJYSFJcbiAgICAgICAgICogQHBhcmFtIHs/fSBfYmFzZVJlc3BvbnNlT3B0aW9uc1xuICAgICAgICAgKiBAcGFyYW0gez99IF94c3JmU3RyYXRlZ3lcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIFhIUkJhY2tlbmQoX2Jyb3dzZXJYSFIsIF9iYXNlUmVzcG9uc2VPcHRpb25zLCBfeHNyZlN0cmF0ZWd5KSB7XG4gICAgICAgICAgICB0aGlzLl9icm93c2VyWEhSID0gX2Jyb3dzZXJYSFI7XG4gICAgICAgICAgICB0aGlzLl9iYXNlUmVzcG9uc2VPcHRpb25zID0gX2Jhc2VSZXNwb25zZU9wdGlvbnM7XG4gICAgICAgICAgICB0aGlzLl94c3JmU3RyYXRlZ3kgPSBfeHNyZlN0cmF0ZWd5O1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gez99IHJlcXVlc3RcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIFhIUkJhY2tlbmQucHJvdG90eXBlLmNyZWF0ZUNvbm5lY3Rpb24gPSBmdW5jdGlvbiAocmVxdWVzdCkge1xuICAgICAgICAgICAgdGhpcy5feHNyZlN0cmF0ZWd5LmNvbmZpZ3VyZVJlcXVlc3QocmVxdWVzdCk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFhIUkNvbm5lY3Rpb24ocmVxdWVzdCwgdGhpcy5fYnJvd3NlclhIUiwgdGhpcy5fYmFzZVJlc3BvbnNlT3B0aW9ucyk7XG4gICAgICAgIH07XG4gICAgICAgIFhIUkJhY2tlbmQuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5JbmplY3RhYmxlIH0sXG4gICAgICAgIF07XG4gICAgICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgICAgICBYSFJCYWNrZW5kLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW1xuICAgICAgICAgICAgeyB0eXBlOiBCcm93c2VyWGhyLCB9LFxuICAgICAgICAgICAgeyB0eXBlOiBSZXNwb25zZU9wdGlvbnMsIH0sXG4gICAgICAgICAgICB7IHR5cGU6IFhTUkZTdHJhdGVneSwgfSxcbiAgICAgICAgXTsgfTtcbiAgICAgICAgcmV0dXJuIFhIUkJhY2tlbmQ7XG4gICAgfSgpKTtcblxuICAgIC8qKlxuICAgICAqIEBsaWNlbnNlXG4gICAgICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gICAgICpcbiAgICAgKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICAgICAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAgICAgKi9cbiAgICB2YXIgX19leHRlbmRzJDMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgcmVxdWVzdCBvcHRpb25zIG9iamVjdCB0byBiZSBvcHRpb25hbGx5IHByb3ZpZGVkIHdoZW4gaW5zdGFudGlhdGluZyBhXG4gICAgICoge1xcQGxpbmsgUmVxdWVzdH0uXG4gICAgICpcbiAgICAgKiBUaGlzIGNsYXNzIGlzIGJhc2VkIG9uIHRoZSBgUmVxdWVzdEluaXRgIGRlc2NyaXB0aW9uIGluIHRoZSBbRmV0Y2hcbiAgICAgKiBTcGVjXShodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jcmVxdWVzdGluaXQpLlxuICAgICAqXG4gICAgICogQWxsIHZhbHVlcyBhcmUgbnVsbCBieSBkZWZhdWx0LiBUeXBpY2FsIGRlZmF1bHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUge1xcQGxpbmsgQmFzZVJlcXVlc3RPcHRpb25zfVxuICAgICAqIGNsYXNzLCB3aGljaCBzdWItY2xhc3NlcyBgUmVxdWVzdE9wdGlvbnNgLlxuICAgICAqXG4gICAgICogIyMjIEV4YW1wbGUgKFtsaXZlIGRlbW9dKGh0dHA6Ly9wbG5rci5jby9lZGl0LzdXdmkzbGZMcTQxYVFQS2x4QjRPP3A9cHJldmlldykpXG4gICAgICpcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogaW1wb3J0IHtSZXF1ZXN0T3B0aW9ucywgUmVxdWVzdCwgUmVxdWVzdE1ldGhvZH0gZnJvbSAnXFxAYW5ndWxhci9odHRwJztcbiAgICAgKlxuICAgICAqIHZhciBvcHRpb25zID0gbmV3IFJlcXVlc3RPcHRpb25zKHtcbiAgICAgKiAgIG1ldGhvZDogUmVxdWVzdE1ldGhvZC5Qb3N0LFxuICAgICAqICAgdXJsOiAnaHR0cHM6Ly9nb29nbGUuY29tJ1xuICAgICAqIH0pO1xuICAgICAqIHZhciByZXEgPSBuZXcgUmVxdWVzdChvcHRpb25zKTtcbiAgICAgKiBjb25zb2xlLmxvZygncmVxLm1ldGhvZDonLCBSZXF1ZXN0TWV0aG9kW3JlcS5tZXRob2RdKTsgLy8gUG9zdFxuICAgICAqIGNvbnNvbGUubG9nKCdvcHRpb25zLnVybDonLCBvcHRpb25zLnVybCk7IC8vIGh0dHBzOi8vZ29vZ2xlLmNvbVxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogXFxAZXhwZXJpbWVudGFsXG4gICAgICovXG4gICAgdmFyIFJlcXVlc3RPcHRpb25zID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7Pz19IF9fMFxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gUmVxdWVzdE9wdGlvbnMoX2EpIHtcbiAgICAgICAgICAgIHZhciBfYiA9IF9hID09PSB2b2lkIDAgPyB7fSA6IF9hLCBtZXRob2QgPSBfYi5tZXRob2QsIGhlYWRlcnMgPSBfYi5oZWFkZXJzLCBib2R5ID0gX2IuYm9keSwgdXJsID0gX2IudXJsLCBzZWFyY2ggPSBfYi5zZWFyY2gsIHdpdGhDcmVkZW50aWFscyA9IF9iLndpdGhDcmVkZW50aWFscywgcmVzcG9uc2VUeXBlID0gX2IucmVzcG9uc2VUeXBlO1xuICAgICAgICAgICAgdGhpcy5tZXRob2QgPSBtZXRob2QgIT0gbnVsbCA/IG5vcm1hbGl6ZU1ldGhvZE5hbWUobWV0aG9kKSA6IG51bGw7XG4gICAgICAgICAgICB0aGlzLmhlYWRlcnMgPSBoZWFkZXJzICE9IG51bGwgPyBoZWFkZXJzIDogbnVsbDtcbiAgICAgICAgICAgIHRoaXMuYm9keSA9IGJvZHkgIT0gbnVsbCA/IGJvZHkgOiBudWxsO1xuICAgICAgICAgICAgdGhpcy51cmwgPSB1cmwgIT0gbnVsbCA/IHVybCA6IG51bGw7XG4gICAgICAgICAgICB0aGlzLnNlYXJjaCA9XG4gICAgICAgICAgICAgICAgc2VhcmNoICE9IG51bGwgPyAodHlwZW9mIHNlYXJjaCA9PT0gJ3N0cmluZycgPyBuZXcgVVJMU2VhcmNoUGFyYW1zKHNlYXJjaCkgOiBzZWFyY2gpIDogbnVsbDtcbiAgICAgICAgICAgIHRoaXMud2l0aENyZWRlbnRpYWxzID0gd2l0aENyZWRlbnRpYWxzICE9IG51bGwgPyB3aXRoQ3JlZGVudGlhbHMgOiBudWxsO1xuICAgICAgICAgICAgdGhpcy5yZXNwb25zZVR5cGUgPSByZXNwb25zZVR5cGUgIT0gbnVsbCA/IHJlc3BvbnNlVHlwZSA6IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgYSBjb3B5IG9mIHRoZSBgUmVxdWVzdE9wdGlvbnNgIGluc3RhbmNlLCB1c2luZyB0aGUgb3B0aW9uYWwgaW5wdXQgYXMgdmFsdWVzIHRvIG92ZXJyaWRlXG4gICAgICAgICAqIGV4aXN0aW5nIHZhbHVlcy4gVGhpcyBtZXRob2Qgd2lsbCBub3QgY2hhbmdlIHRoZSB2YWx1ZXMgb2YgdGhlIGluc3RhbmNlIG9uIHdoaWNoIGl0IGlzIGJlaW5nXG4gICAgICAgICAqIGNhbGxlZC5cbiAgICAgICAgICpcbiAgICAgICAgICogTm90ZSB0aGF0IGBoZWFkZXJzYCBhbmQgYHNlYXJjaGAgd2lsbCBvdmVycmlkZSBleGlzdGluZyB2YWx1ZXMgY29tcGxldGVseSBpZiBwcmVzZW50IGluXG4gICAgICAgICAqIHRoZSBgb3B0aW9uc2Agb2JqZWN0LiBJZiB0aGVzZSB2YWx1ZXMgc2hvdWxkIGJlIG1lcmdlZCwgaXQgc2hvdWxkIGJlIGRvbmUgcHJpb3IgdG8gY2FsbGluZ1xuICAgICAgICAgKiBgbWVyZ2VgIG9uIHRoZSBgUmVxdWVzdE9wdGlvbnNgIGluc3RhbmNlLlxuICAgICAgICAgKlxuICAgICAgICAgKiAjIyMgRXhhbXBsZSAoW2xpdmUgZGVtb10oaHR0cDovL3BsbmtyLmNvL2VkaXQvNnc4WEE4WVRrRFJjUFlwZEI5ZGs/cD1wcmV2aWV3KSlcbiAgICAgICAgICpcbiAgICAgICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAgICAgKiBpbXBvcnQge1JlcXVlc3RPcHRpb25zLCBSZXF1ZXN0LCBSZXF1ZXN0TWV0aG9kfSBmcm9tICdcXEBhbmd1bGFyL2h0dHAnO1xuICAgICAgICAgKlxuICAgICAgICAgKiB2YXIgb3B0aW9ucyA9IG5ldyBSZXF1ZXN0T3B0aW9ucyh7XG4gICAgICAgICAqICAgbWV0aG9kOiBSZXF1ZXN0TWV0aG9kLlBvc3RcbiAgICAgICAgICogfSk7XG4gICAgICAgICAqIHZhciByZXEgPSBuZXcgUmVxdWVzdChvcHRpb25zLm1lcmdlKHtcbiAgICAgICAgICogICB1cmw6ICdodHRwczovL2dvb2dsZS5jb20nXG4gICAgICAgICAqIH0pKTtcbiAgICAgICAgICogY29uc29sZS5sb2coJ3JlcS5tZXRob2Q6JywgUmVxdWVzdE1ldGhvZFtyZXEubWV0aG9kXSk7IC8vIFBvc3RcbiAgICAgICAgICogY29uc29sZS5sb2coJ29wdGlvbnMudXJsOicsIG9wdGlvbnMudXJsKTsgLy8gbnVsbFxuICAgICAgICAgKiBjb25zb2xlLmxvZygncmVxLnVybDonLCByZXEudXJsKTsgLy8gaHR0cHM6Ly9nb29nbGUuY29tXG4gICAgICAgICAqIGBgYFxuICAgICAgICAgKiBAcGFyYW0gez89fSBvcHRpb25zXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBSZXF1ZXN0T3B0aW9ucy5wcm90b3R5cGUubWVyZ2UgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZXF1ZXN0T3B0aW9ucyh7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiBvcHRpb25zICYmIG9wdGlvbnMubWV0aG9kICE9IG51bGwgPyBvcHRpb25zLm1ldGhvZCA6IHRoaXMubWV0aG9kLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IG9wdGlvbnMgJiYgb3B0aW9ucy5oZWFkZXJzICE9IG51bGwgPyBvcHRpb25zLmhlYWRlcnMgOiBuZXcgSGVhZGVycyh0aGlzLmhlYWRlcnMpLFxuICAgICAgICAgICAgICAgIGJvZHk6IG9wdGlvbnMgJiYgb3B0aW9ucy5ib2R5ICE9IG51bGwgPyBvcHRpb25zLmJvZHkgOiB0aGlzLmJvZHksXG4gICAgICAgICAgICAgICAgdXJsOiBvcHRpb25zICYmIG9wdGlvbnMudXJsICE9IG51bGwgPyBvcHRpb25zLnVybCA6IHRoaXMudXJsLFxuICAgICAgICAgICAgICAgIHNlYXJjaDogb3B0aW9ucyAmJiBvcHRpb25zLnNlYXJjaCAhPSBudWxsID9cbiAgICAgICAgICAgICAgICAgICAgKHR5cGVvZiBvcHRpb25zLnNlYXJjaCA9PT0gJ3N0cmluZycgPyBuZXcgVVJMU2VhcmNoUGFyYW1zKG9wdGlvbnMuc2VhcmNoKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnNlYXJjaC5jbG9uZSgpKSA6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2VhcmNoLFxuICAgICAgICAgICAgICAgIHdpdGhDcmVkZW50aWFsczogb3B0aW9ucyAmJiBvcHRpb25zLndpdGhDcmVkZW50aWFscyAhPSBudWxsID8gb3B0aW9ucy53aXRoQ3JlZGVudGlhbHMgOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLndpdGhDcmVkZW50aWFscyxcbiAgICAgICAgICAgICAgICByZXNwb25zZVR5cGU6IG9wdGlvbnMgJiYgb3B0aW9ucy5yZXNwb25zZVR5cGUgIT0gbnVsbCA/IG9wdGlvbnMucmVzcG9uc2VUeXBlIDpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXNwb25zZVR5cGVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gUmVxdWVzdE9wdGlvbnM7XG4gICAgfSgpKTtcbiAgICAvKipcbiAgICAgKiBTdWJjbGFzcyBvZiB7XFxAbGluayBSZXF1ZXN0T3B0aW9uc30sIHdpdGggZGVmYXVsdCB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBEZWZhdWx0IHZhbHVlczpcbiAgICAgKiAgKiBtZXRob2Q6IHtcXEBsaW5rIFJlcXVlc3RNZXRob2QgUmVxdWVzdE1ldGhvZC5HZXR9XG4gICAgICogICogaGVhZGVyczogZW1wdHkge1xcQGxpbmsgSGVhZGVyc30gb2JqZWN0XG4gICAgICpcbiAgICAgKiBUaGlzIGNsYXNzIGNvdWxkIGJlIGV4dGVuZGVkIGFuZCBib3VuZCB0byB0aGUge1xcQGxpbmsgUmVxdWVzdE9wdGlvbnN9IGNsYXNzXG4gICAgICogd2hlbiBjb25maWd1cmluZyBhbiB7XFxAbGluayBJbmplY3Rvcn0sIGluIG9yZGVyIHRvIG92ZXJyaWRlIHRoZSBkZWZhdWx0IG9wdGlvbnNcbiAgICAgKiB1c2VkIGJ5IHtcXEBsaW5rIEh0dHB9IHRvIGNyZWF0ZSBhbmQgc2VuZCB7XFxAbGluayBSZXF1ZXN0IFJlcXVlc3RzfS5cbiAgICAgKlxuICAgICAqICMjIyBFeGFtcGxlIChbbGl2ZSBkZW1vXShodHRwOi8vcGxua3IuY28vZWRpdC9MRUtWU3g/cD1wcmV2aWV3KSlcbiAgICAgKlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBpbXBvcnQge3Byb3ZpZGV9IGZyb20gJ1xcQGFuZ3VsYXIvY29yZSc7XG4gICAgICogaW1wb3J0IHtib290c3RyYXB9IGZyb20gJ1xcQGFuZ3VsYXIvcGxhdGZvcm0tYnJvd3Nlci9icm93c2VyJztcbiAgICAgKiBpbXBvcnQge0hUVFBfUFJPVklERVJTLCBIdHRwLCBCYXNlUmVxdWVzdE9wdGlvbnMsIFJlcXVlc3RPcHRpb25zfSBmcm9tICdcXEBhbmd1bGFyL2h0dHAnO1xuICAgICAqIGltcG9ydCB7QXBwfSBmcm9tICcuL215YXBwJztcbiAgICAgKlxuICAgICAqIGNsYXNzIE15T3B0aW9ucyBleHRlbmRzIEJhc2VSZXF1ZXN0T3B0aW9ucyB7XG4gICAgICogICBzZWFyY2g6IHN0cmluZyA9ICdjb3JlVGVhbT10cnVlJztcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBib290c3RyYXAoQXBwLCBbSFRUUF9QUk9WSURFUlMsIHtwcm92aWRlOiBSZXF1ZXN0T3B0aW9ucywgdXNlQ2xhc3M6IE15T3B0aW9uc31dKTtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIFRoZSBvcHRpb25zIGNvdWxkIGFsc28gYmUgZXh0ZW5kZWQgd2hlbiBtYW51YWxseSBjcmVhdGluZyBhIHtcXEBsaW5rIFJlcXVlc3R9XG4gICAgICogb2JqZWN0LlxuICAgICAqXG4gICAgICogIyMjIEV4YW1wbGUgKFtsaXZlIGRlbW9dKGh0dHA6Ly9wbG5rci5jby9lZGl0L295Qm9Fdk50RGhPU2ZpOVl4YVZiP3A9cHJldmlldykpXG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKiBpbXBvcnQge0Jhc2VSZXF1ZXN0T3B0aW9ucywgUmVxdWVzdCwgUmVxdWVzdE1ldGhvZH0gZnJvbSAnXFxAYW5ndWxhci9odHRwJztcbiAgICAgKlxuICAgICAqIHZhciBvcHRpb25zID0gbmV3IEJhc2VSZXF1ZXN0T3B0aW9ucygpO1xuICAgICAqIHZhciByZXEgPSBuZXcgUmVxdWVzdChvcHRpb25zLm1lcmdlKHtcbiAgICAgKiAgIG1ldGhvZDogUmVxdWVzdE1ldGhvZC5Qb3N0LFxuICAgICAqICAgdXJsOiAnaHR0cHM6Ly9nb29nbGUuY29tJ1xuICAgICAqIH0pKTtcbiAgICAgKiBjb25zb2xlLmxvZygncmVxLm1ldGhvZDonLCBSZXF1ZXN0TWV0aG9kW3JlcS5tZXRob2RdKTsgLy8gUG9zdFxuICAgICAqIGNvbnNvbGUubG9nKCdvcHRpb25zLnVybDonLCBvcHRpb25zLnVybCk7IC8vIG51bGxcbiAgICAgKiBjb25zb2xlLmxvZygncmVxLnVybDonLCByZXEudXJsKTsgLy8gaHR0cHM6Ly9nb29nbGUuY29tXG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBcXEBleHBlcmltZW50YWxcbiAgICAgKi9cbiAgICB2YXIgQmFzZVJlcXVlc3RPcHRpb25zID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzJDMoQmFzZVJlcXVlc3RPcHRpb25zLCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiBCYXNlUmVxdWVzdE9wdGlvbnMoKSB7XG4gICAgICAgICAgICBfc3VwZXIuY2FsbCh0aGlzLCB7IG1ldGhvZDogUmVxdWVzdE1ldGhvZC5HZXQsIGhlYWRlcnM6IG5ldyBIZWFkZXJzKCkgfSk7XG4gICAgICAgIH1cbiAgICAgICAgQmFzZVJlcXVlc3RPcHRpb25zLmRlY29yYXRvcnMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6IF9hbmd1bGFyX2NvcmUuSW5qZWN0YWJsZSB9LFxuICAgICAgICBdO1xuICAgICAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICAgICAgQmFzZVJlcXVlc3RPcHRpb25zLmN0b3JQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW107IH07XG4gICAgICAgIHJldHVybiBCYXNlUmVxdWVzdE9wdGlvbnM7XG4gICAgfShSZXF1ZXN0T3B0aW9ucykpO1xuXG4gICAgLyoqXG4gICAgICogQGxpY2Vuc2VcbiAgICAgKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAgICAgKlxuICAgICAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gICAgICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICAgICAqL1xuICAgIHZhciBfX2V4dGVuZHMkNSA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYFJlcXVlc3RgIGluc3RhbmNlcyBmcm9tIHByb3ZpZGVkIHZhbHVlcy5cbiAgICAgKlxuICAgICAqIFRoZSBSZXF1ZXN0J3MgaW50ZXJmYWNlIGlzIGluc3BpcmVkIGJ5IHRoZSBSZXF1ZXN0IGNvbnN0cnVjdG9yIGRlZmluZWQgaW4gdGhlIFtGZXRjaFxuICAgICAqIFNwZWNdKGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNyZXF1ZXN0LWNsYXNzKSxcbiAgICAgKiBidXQgaXMgY29uc2lkZXJlZCBhIHN0YXRpYyB2YWx1ZSB3aG9zZSBib2R5IGNhbiBiZSBhY2Nlc3NlZCBtYW55IHRpbWVzLiBUaGVyZSBhcmUgb3RoZXJcbiAgICAgKiBkaWZmZXJlbmNlcyBpbiB0aGUgaW1wbGVtZW50YXRpb24sIGJ1dCB0aGlzIGlzIHRoZSBtb3N0IHNpZ25pZmljYW50LlxuICAgICAqXG4gICAgICogYFJlcXVlc3RgIGluc3RhbmNlcyBhcmUgdHlwaWNhbGx5IGNyZWF0ZWQgYnkgaGlnaGVyLWxldmVsIGNsYXNzZXMsIGxpa2Uge1xcQGxpbmsgSHR0cH0gYW5kXG4gICAgICoge1xcQGxpbmsgSnNvbnB9LCBidXQgaXQgbWF5IG9jY2FzaW9uYWxseSBiZSB1c2VmdWwgdG8gZXhwbGljaXRseSBjcmVhdGUgYFJlcXVlc3RgIGluc3RhbmNlcy5cbiAgICAgKiBPbmUgc3VjaCBleGFtcGxlIGlzIHdoZW4gY3JlYXRpbmcgc2VydmljZXMgdGhhdCB3cmFwIGhpZ2hlci1sZXZlbCBzZXJ2aWNlcywgbGlrZSB7XFxAbGluayBIdHRwfSxcbiAgICAgKiB3aGVyZSBpdCBtYXkgYmUgdXNlZnVsIHRvIGdlbmVyYXRlIGEgYFJlcXVlc3RgIHdpdGggYXJiaXRyYXJ5IGhlYWRlcnMgYW5kIHNlYXJjaCBwYXJhbXMuXG4gICAgICpcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogaW1wb3J0IHtJbmplY3RhYmxlLCBJbmplY3Rvcn0gZnJvbSAnXFxAYW5ndWxhci9jb3JlJztcbiAgICAgKiBpbXBvcnQge0hUVFBfUFJPVklERVJTLCBIdHRwLCBSZXF1ZXN0LCBSZXF1ZXN0TWV0aG9kfSBmcm9tICdcXEBhbmd1bGFyL2h0dHAnO1xuICAgICAqXG4gICAgICogXFxASW5qZWN0YWJsZSgpXG4gICAgICogY2xhc3MgQXV0b0F1dGhlbnRpY2F0b3Ige1xuICAgICAqICAgY29uc3RydWN0b3IocHVibGljIGh0dHA6SHR0cCkge31cbiAgICAgKiAgIHJlcXVlc3QodXJsOnN0cmluZykge1xuICAgICAqICAgICByZXR1cm4gdGhpcy5odHRwLnJlcXVlc3QobmV3IFJlcXVlc3Qoe1xuICAgICAqICAgICAgIG1ldGhvZDogUmVxdWVzdE1ldGhvZC5HZXQsXG4gICAgICogICAgICAgdXJsOiB1cmwsXG4gICAgICogICAgICAgc2VhcmNoOiAncGFzc3dvcmQ9MTIzJ1xuICAgICAqICAgICB9KSk7XG4gICAgICogICB9XG4gICAgICogfVxuICAgICAqXG4gICAgICogdmFyIGluamVjdG9yID0gSW5qZWN0b3IucmVzb2x2ZUFuZENyZWF0ZShbSFRUUF9QUk9WSURFUlMsIEF1dG9BdXRoZW50aWNhdG9yXSk7XG4gICAgICogdmFyIGF1dGhlbnRpY2F0b3IgPSBpbmplY3Rvci5nZXQoQXV0b0F1dGhlbnRpY2F0b3IpO1xuICAgICAqIGF1dGhlbnRpY2F0b3IucmVxdWVzdCgncGVvcGxlLmpzb24nKS5zdWJzY3JpYmUocmVzID0+IHtcbiAgICAgKiAgIC8vVVJMIHNob3VsZCBoYXZlIGluY2x1ZGVkICc/cGFzc3dvcmQ9MTIzJ1xuICAgICAqICAgY29uc29sZS5sb2coJ3Blb3BsZScsIHJlcy5qc29uKCkpO1xuICAgICAqIH0pO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogXFxAZXhwZXJpbWVudGFsXG4gICAgICovXG4gICAgdmFyIFJlcXVlc3QgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMkNShSZXF1ZXN0LCBfc3VwZXIpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHs/fSByZXF1ZXN0T3B0aW9uc1xuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gUmVxdWVzdChyZXF1ZXN0T3B0aW9ucykge1xuICAgICAgICAgICAgX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgICAgICAgICAvLyBUT0RPOiBhc3NlcnQgdGhhdCB1cmwgaXMgcHJlc2VudFxuICAgICAgICAgICAgdmFyIHVybCA9IHJlcXVlc3RPcHRpb25zLnVybDtcbiAgICAgICAgICAgIHRoaXMudXJsID0gcmVxdWVzdE9wdGlvbnMudXJsO1xuICAgICAgICAgICAgaWYgKHJlcXVlc3RPcHRpb25zLnNlYXJjaCkge1xuICAgICAgICAgICAgICAgIHZhciBzZWFyY2ggPSByZXF1ZXN0T3B0aW9ucy5zZWFyY2gudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICBpZiAoc2VhcmNoLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHByZWZpeCA9ICc/JztcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMudXJsLmluZGV4T2YoJz8nKSAhPSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJlZml4ID0gKHRoaXMudXJsW3RoaXMudXJsLmxlbmd0aCAtIDFdID09ICcmJykgPyAnJyA6ICcmJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBqdXN0IGRlbGV0ZSBzZWFyY2gtcXVlcnktbG9va2luZyBzdHJpbmcgaW4gdXJsP1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnVybCA9IHVybCArIHByZWZpeCArIHNlYXJjaDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9ib2R5ID0gcmVxdWVzdE9wdGlvbnMuYm9keTtcbiAgICAgICAgICAgIHRoaXMubWV0aG9kID0gbm9ybWFsaXplTWV0aG9kTmFtZShyZXF1ZXN0T3B0aW9ucy5tZXRob2QpO1xuICAgICAgICAgICAgLy8gVE9ETyhqZWZmYmNyb3NzKTogaW1wbGVtZW50IGJlaGF2aW9yXG4gICAgICAgICAgICAvLyBEZWZhdWx0cyB0byAnb21pdCcsIGNvbnNpc3RlbnQgd2l0aCBicm93c2VyXG4gICAgICAgICAgICB0aGlzLmhlYWRlcnMgPSBuZXcgSGVhZGVycyhyZXF1ZXN0T3B0aW9ucy5oZWFkZXJzKTtcbiAgICAgICAgICAgIHRoaXMuY29udGVudFR5cGUgPSB0aGlzLmRldGVjdENvbnRlbnRUeXBlKCk7XG4gICAgICAgICAgICB0aGlzLndpdGhDcmVkZW50aWFscyA9IHJlcXVlc3RPcHRpb25zLndpdGhDcmVkZW50aWFscztcbiAgICAgICAgICAgIHRoaXMucmVzcG9uc2VUeXBlID0gcmVxdWVzdE9wdGlvbnMucmVzcG9uc2VUeXBlO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBjb250ZW50IHR5cGUgZW51bSBiYXNlZCBvbiBoZWFkZXIgb3B0aW9ucy5cbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIFJlcXVlc3QucHJvdG90eXBlLmRldGVjdENvbnRlbnRUeXBlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgc3dpdGNoICh0aGlzLmhlYWRlcnMuZ2V0KCdjb250ZW50LXR5cGUnKSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ2FwcGxpY2F0aW9uL2pzb24nOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gQ29udGVudFR5cGUuSlNPTjtcbiAgICAgICAgICAgICAgICBjYXNlICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gQ29udGVudFR5cGUuRk9STTtcbiAgICAgICAgICAgICAgICBjYXNlICdtdWx0aXBhcnQvZm9ybS1kYXRhJzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIENvbnRlbnRUeXBlLkZPUk1fREFUQTtcbiAgICAgICAgICAgICAgICBjYXNlICd0ZXh0L3BsYWluJzpcbiAgICAgICAgICAgICAgICBjYXNlICd0ZXh0L2h0bWwnOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gQ29udGVudFR5cGUuVEVYVDtcbiAgICAgICAgICAgICAgICBjYXNlICdhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW0nOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fYm9keSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyJDEgPyBDb250ZW50VHlwZS5BUlJBWV9CVUZGRVIgOiBDb250ZW50VHlwZS5CTE9CO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmRldGVjdENvbnRlbnRUeXBlRnJvbUJvZHkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgdGhlIGNvbnRlbnQgdHlwZSBvZiByZXF1ZXN0J3MgYm9keSBiYXNlZCBvbiBpdHMgdHlwZS5cbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIFJlcXVlc3QucHJvdG90eXBlLmRldGVjdENvbnRlbnRUeXBlRnJvbUJvZHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fYm9keSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIENvbnRlbnRUeXBlLk5PTkU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLl9ib2R5IGluc3RhbmNlb2YgVVJMU2VhcmNoUGFyYW1zKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIENvbnRlbnRUeXBlLkZPUk07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLl9ib2R5IGluc3RhbmNlb2YgRm9ybURhdGEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gQ29udGVudFR5cGUuRk9STV9EQVRBO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5fYm9keSBpbnN0YW5jZW9mIEJsb2IkMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBDb250ZW50VHlwZS5CTE9CO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5fYm9keSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyJDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gQ29udGVudFR5cGUuQVJSQVlfQlVGRkVSO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5fYm9keSAmJiB0eXBlb2YgdGhpcy5fYm9keSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gQ29udGVudFR5cGUuSlNPTjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBDb250ZW50VHlwZS5URVhUO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyB0aGUgcmVxdWVzdCdzIGJvZHkgYWNjb3JkaW5nIHRvIGl0cyB0eXBlLiBJZiBib2R5IGlzIHVuZGVmaW5lZCwgcmV0dXJuXG4gICAgICAgICAqIG51bGwuXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBSZXF1ZXN0LnByb3RvdHlwZS5nZXRCb2R5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgc3dpdGNoICh0aGlzLmNvbnRlbnRUeXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBDb250ZW50VHlwZS5KU09OOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy50ZXh0KCk7XG4gICAgICAgICAgICAgICAgY2FzZSBDb250ZW50VHlwZS5GT1JNOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy50ZXh0KCk7XG4gICAgICAgICAgICAgICAgY2FzZSBDb250ZW50VHlwZS5GT1JNX0RBVEE6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9ib2R5O1xuICAgICAgICAgICAgICAgIGNhc2UgQ29udGVudFR5cGUuVEVYVDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudGV4dCgpO1xuICAgICAgICAgICAgICAgIGNhc2UgQ29udGVudFR5cGUuQkxPQjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYmxvYigpO1xuICAgICAgICAgICAgICAgIGNhc2UgQ29udGVudFR5cGUuQVJSQVlfQlVGRkVSOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5hcnJheUJ1ZmZlcigpO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gUmVxdWVzdDtcbiAgICB9KEJvZHkpKTtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBub29wID0gZnVuY3Rpb24gKCkgeyB9O1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIHcgPSB0eXBlb2Ygd2luZG93ID09ICdvYmplY3QnID8gd2luZG93IDogbm9vcDtcbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBGb3JtRGF0YSA9ICgodykgLyoqIFRPRE8gIzkxMDAgKi8pWydGb3JtRGF0YSddIHx8IG5vb3A7XG4gICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gQmxvYiQxID0gKCh3KSAvKiogVE9ETyAjOTEwMCAqLylbJ0Jsb2InXSB8fCBub29wO1xuICAgIHZhciAvKiogQHR5cGUgez99ICovIEFycmF5QnVmZmVyJDEgPSAoKHcpIC8qKiBUT0RPICM5MTAwICovKVsnQXJyYXlCdWZmZXInXSB8fCBub29wO1xuXG4gICAgLyoqXG4gICAgICogQGxpY2Vuc2VcbiAgICAgKiBDb3B5cmlnaHQgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAgICAgKlxuICAgICAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gICAgICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICAgICAqL1xuICAgIHZhciBfX2V4dGVuZHMkNCA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gYmFja2VuZFxuICAgICAqIEBwYXJhbSB7P30gcmVxdWVzdFxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZnVuY3Rpb24gaHR0cFJlcXVlc3QoYmFja2VuZCwgcmVxdWVzdCkge1xuICAgICAgICByZXR1cm4gYmFja2VuZC5jcmVhdGVDb25uZWN0aW9uKHJlcXVlc3QpLnJlc3BvbnNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGRlZmF1bHRPcHRzXG4gICAgICogQHBhcmFtIHs/fSBwcm92aWRlZE9wdHNcbiAgICAgKiBAcGFyYW0gez99IG1ldGhvZFxuICAgICAqIEBwYXJhbSB7P30gdXJsXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtZXJnZU9wdGlvbnMoZGVmYXVsdE9wdHMsIHByb3ZpZGVkT3B0cywgbWV0aG9kLCB1cmwpIHtcbiAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gbmV3T3B0aW9ucyA9IGRlZmF1bHRPcHRzO1xuICAgICAgICBpZiAocHJvdmlkZWRPcHRzKSB7XG4gICAgICAgICAgICAvLyBIYWNrIHNvIERhcnQgY2FuIHVzZWQgbmFtZWQgcGFyYW1ldGVyc1xuICAgICAgICAgICAgcmV0dXJuIG5ld09wdGlvbnMubWVyZ2UobmV3IFJlcXVlc3RPcHRpb25zKHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6IHByb3ZpZGVkT3B0cy5tZXRob2QgfHwgbWV0aG9kLFxuICAgICAgICAgICAgICAgIHVybDogcHJvdmlkZWRPcHRzLnVybCB8fCB1cmwsXG4gICAgICAgICAgICAgICAgc2VhcmNoOiBwcm92aWRlZE9wdHMuc2VhcmNoLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHByb3ZpZGVkT3B0cy5oZWFkZXJzLFxuICAgICAgICAgICAgICAgIGJvZHk6IHByb3ZpZGVkT3B0cy5ib2R5LFxuICAgICAgICAgICAgICAgIHdpdGhDcmVkZW50aWFsczogcHJvdmlkZWRPcHRzLndpdGhDcmVkZW50aWFscyxcbiAgICAgICAgICAgICAgICByZXNwb25zZVR5cGU6IHByb3ZpZGVkT3B0cy5yZXNwb25zZVR5cGVcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3T3B0aW9ucy5tZXJnZShuZXcgUmVxdWVzdE9wdGlvbnMoeyBtZXRob2Q6IG1ldGhvZCwgdXJsOiB1cmwgfSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtcyBodHRwIHJlcXVlc3RzIHVzaW5nIGBYTUxIdHRwUmVxdWVzdGAgYXMgdGhlIGRlZmF1bHQgYmFja2VuZC5cbiAgICAgKlxuICAgICAqIGBIdHRwYCBpcyBhdmFpbGFibGUgYXMgYW4gaW5qZWN0YWJsZSBjbGFzcywgd2l0aCBtZXRob2RzIHRvIHBlcmZvcm0gaHR0cCByZXF1ZXN0cy4gQ2FsbGluZ1xuICAgICAqIGByZXF1ZXN0YCByZXR1cm5zIGFuIGBPYnNlcnZhYmxlYCB3aGljaCB3aWxsIGVtaXQgYSBzaW5nbGUge1xcQGxpbmsgUmVzcG9uc2V9IHdoZW4gYVxuICAgICAqIHJlc3BvbnNlIGlzIHJlY2VpdmVkLlxuICAgICAqXG4gICAgICogIyMjIEV4YW1wbGVcbiAgICAgKlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBpbXBvcnQge0h0dHAsIEhUVFBfUFJPVklERVJTfSBmcm9tICdcXEBhbmd1bGFyL2h0dHAnO1xuICAgICAqIGltcG9ydCAncnhqcy9hZGQvb3BlcmF0b3IvbWFwJ1xuICAgICAqIFxcQENvbXBvbmVudCh7XG4gICAgICogICBzZWxlY3RvcjogJ2h0dHAtYXBwJyxcbiAgICAgKiAgIHZpZXdQcm92aWRlcnM6IFtIVFRQX1BST1ZJREVSU10sXG4gICAgICogICB0ZW1wbGF0ZVVybDogJ3Blb3BsZS5odG1sJ1xuICAgICAqIH0pXG4gICAgICogY2xhc3MgUGVvcGxlQ29tcG9uZW50IHtcbiAgICAgKiAgIGNvbnN0cnVjdG9yKGh0dHA6IEh0dHApIHtcbiAgICAgKiAgICAgaHR0cC5nZXQoJ3Blb3BsZS5qc29uJylcbiAgICAgKiAgICAgICAvLyBDYWxsIG1hcCBvbiB0aGUgcmVzcG9uc2Ugb2JzZXJ2YWJsZSB0byBnZXQgdGhlIHBhcnNlZCBwZW9wbGUgb2JqZWN0XG4gICAgICogICAgICAgLm1hcChyZXMgPT4gcmVzLmpzb24oKSlcbiAgICAgKiAgICAgICAvLyBTdWJzY3JpYmUgdG8gdGhlIG9ic2VydmFibGUgdG8gZ2V0IHRoZSBwYXJzZWQgcGVvcGxlIG9iamVjdCBhbmQgYXR0YWNoIGl0IHRvIHRoZVxuICAgICAqICAgICAgIC8vIGNvbXBvbmVudFxuICAgICAqICAgICAgIC5zdWJzY3JpYmUocGVvcGxlID0+IHRoaXMucGVvcGxlID0gcGVvcGxlKTtcbiAgICAgKiAgIH1cbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKlxuICAgICAqICMjIyBFeGFtcGxlXG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKiBodHRwLmdldCgncGVvcGxlLmpzb24nKS5zdWJzY3JpYmUoKHJlczpSZXNwb25zZSkgPT4gdGhpcy5wZW9wbGUgPSByZXMuanNvbigpKTtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIFRoZSBkZWZhdWx0IGNvbnN0cnVjdCB1c2VkIHRvIHBlcmZvcm0gcmVxdWVzdHMsIGBYTUxIdHRwUmVxdWVzdGAsIGlzIGFic3RyYWN0ZWQgYXMgYSBcIkJhY2tlbmRcIiAoXG4gICAgICoge1xcQGxpbmsgWEhSQmFja2VuZH0gaW4gdGhpcyBjYXNlKSwgd2hpY2ggY291bGQgYmUgbW9ja2VkIHdpdGggZGVwZW5kZW5jeSBpbmplY3Rpb24gYnkgcmVwbGFjaW5nXG4gICAgICogdGhlIHtcXEBsaW5rIFhIUkJhY2tlbmR9IHByb3ZpZGVyLCBhcyBpbiB0aGUgZm9sbG93aW5nIGV4YW1wbGU6XG4gICAgICpcbiAgICAgKiAjIyMgRXhhbXBsZVxuICAgICAqXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGltcG9ydCB7QmFzZVJlcXVlc3RPcHRpb25zLCBIdHRwfSBmcm9tICdcXEBhbmd1bGFyL2h0dHAnO1xuICAgICAqIGltcG9ydCB7TW9ja0JhY2tlbmR9IGZyb20gJ1xcQGFuZ3VsYXIvaHR0cC90ZXN0aW5nJztcbiAgICAgKiB2YXIgaW5qZWN0b3IgPSBJbmplY3Rvci5yZXNvbHZlQW5kQ3JlYXRlKFtcbiAgICAgKiAgIEJhc2VSZXF1ZXN0T3B0aW9ucyxcbiAgICAgKiAgIE1vY2tCYWNrZW5kLFxuICAgICAqICAge3Byb3ZpZGU6IEh0dHAsIHVzZUZhY3Rvcnk6XG4gICAgICogICAgICAgZnVuY3Rpb24oYmFja2VuZCwgZGVmYXVsdE9wdGlvbnMpIHtcbiAgICAgKiAgICAgICAgIHJldHVybiBuZXcgSHR0cChiYWNrZW5kLCBkZWZhdWx0T3B0aW9ucyk7XG4gICAgICogICAgICAgfSxcbiAgICAgKiAgICAgICBkZXBzOiBbTW9ja0JhY2tlbmQsIEJhc2VSZXF1ZXN0T3B0aW9uc119XG4gICAgICogXSk7XG4gICAgICogdmFyIGh0dHAgPSBpbmplY3Rvci5nZXQoSHR0cCk7XG4gICAgICogaHR0cC5nZXQoJ3JlcXVlc3QtZnJvbS1tb2NrLWJhY2tlbmQuanNvbicpLnN1YnNjcmliZSgocmVzOlJlc3BvbnNlKSA9PiBkb1NvbWV0aGluZyhyZXMpKTtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIFxcQGV4cGVyaW1lbnRhbFxuICAgICAqL1xuICAgIHZhciBIdHRwID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gX2JhY2tlbmRcbiAgICAgICAgICogQHBhcmFtIHs/fSBfZGVmYXVsdE9wdGlvbnNcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIEh0dHAoX2JhY2tlbmQsIF9kZWZhdWx0T3B0aW9ucykge1xuICAgICAgICAgICAgdGhpcy5fYmFja2VuZCA9IF9iYWNrZW5kO1xuICAgICAgICAgICAgdGhpcy5fZGVmYXVsdE9wdGlvbnMgPSBfZGVmYXVsdE9wdGlvbnM7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFBlcmZvcm1zIGFueSB0eXBlIG9mIGh0dHAgcmVxdWVzdC4gRmlyc3QgYXJndW1lbnQgaXMgcmVxdWlyZWQsIGFuZCBjYW4gZWl0aGVyIGJlIGEgdXJsIG9yXG4gICAgICAgICAqIGEge1xcQGxpbmsgUmVxdWVzdH0gaW5zdGFuY2UuIElmIHRoZSBmaXJzdCBhcmd1bWVudCBpcyBhIHVybCwgYW4gb3B0aW9uYWwge1xcQGxpbmsgUmVxdWVzdE9wdGlvbnN9XG4gICAgICAgICAqIG9iamVjdCBjYW4gYmUgcHJvdmlkZWQgYXMgdGhlIDJuZCBhcmd1bWVudC4gVGhlIG9wdGlvbnMgb2JqZWN0IHdpbGwgYmUgbWVyZ2VkIHdpdGggdGhlIHZhbHVlc1xuICAgICAgICAgKiBvZiB7XFxAbGluayBCYXNlUmVxdWVzdE9wdGlvbnN9IGJlZm9yZSBwZXJmb3JtaW5nIHRoZSByZXF1ZXN0LlxuICAgICAgICAgKiBAcGFyYW0gez99IHVybFxuICAgICAgICAgKiBAcGFyYW0gez89fSBvcHRpb25zXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBIdHRwLnByb3RvdHlwZS5yZXF1ZXN0ID0gZnVuY3Rpb24gKHVybCwgb3B0aW9ucykge1xuICAgICAgICAgICAgdmFyIC8qKiBAdHlwZSB7P30gKi8gcmVzcG9uc2VPYnNlcnZhYmxlO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB1cmwgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgcmVzcG9uc2VPYnNlcnZhYmxlID0gaHR0cFJlcXVlc3QodGhpcy5fYmFja2VuZCwgbmV3IFJlcXVlc3QobWVyZ2VPcHRpb25zKHRoaXMuX2RlZmF1bHRPcHRpb25zLCBvcHRpb25zLCBSZXF1ZXN0TWV0aG9kLkdldCwgLyoqIEB0eXBlIHs/fSAqLyAodXJsKSkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHVybCBpbnN0YW5jZW9mIFJlcXVlc3QpIHtcbiAgICAgICAgICAgICAgICByZXNwb25zZU9ic2VydmFibGUgPSBodHRwUmVxdWVzdCh0aGlzLl9iYWNrZW5kLCB1cmwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgdXJsIHN0cmluZyBvciBSZXF1ZXN0IGluc3RhbmNlLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlT2JzZXJ2YWJsZTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFBlcmZvcm1zIGEgcmVxdWVzdCB3aXRoIGBnZXRgIGh0dHAgbWV0aG9kLlxuICAgICAgICAgKiBAcGFyYW0gez99IHVybFxuICAgICAgICAgKiBAcGFyYW0gez89fSBvcHRpb25zXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBIdHRwLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAodXJsLCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KG5ldyBSZXF1ZXN0KG1lcmdlT3B0aW9ucyh0aGlzLl9kZWZhdWx0T3B0aW9ucywgb3B0aW9ucywgUmVxdWVzdE1ldGhvZC5HZXQsIHVybCkpKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFBlcmZvcm1zIGEgcmVxdWVzdCB3aXRoIGBwb3N0YCBodHRwIG1ldGhvZC5cbiAgICAgICAgICogQHBhcmFtIHs/fSB1cmxcbiAgICAgICAgICogQHBhcmFtIHs/fSBib2R5XG4gICAgICAgICAqIEBwYXJhbSB7Pz19IG9wdGlvbnNcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIEh0dHAucHJvdG90eXBlLnBvc3QgPSBmdW5jdGlvbiAodXJsLCBib2R5LCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KG5ldyBSZXF1ZXN0KG1lcmdlT3B0aW9ucyh0aGlzLl9kZWZhdWx0T3B0aW9ucy5tZXJnZShuZXcgUmVxdWVzdE9wdGlvbnMoeyBib2R5OiBib2R5IH0pKSwgb3B0aW9ucywgUmVxdWVzdE1ldGhvZC5Qb3N0LCB1cmwpKSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQZXJmb3JtcyBhIHJlcXVlc3Qgd2l0aCBgcHV0YCBodHRwIG1ldGhvZC5cbiAgICAgICAgICogQHBhcmFtIHs/fSB1cmxcbiAgICAgICAgICogQHBhcmFtIHs/fSBib2R5XG4gICAgICAgICAqIEBwYXJhbSB7Pz19IG9wdGlvbnNcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIEh0dHAucHJvdG90eXBlLnB1dCA9IGZ1bmN0aW9uICh1cmwsIGJvZHksIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3QobmV3IFJlcXVlc3QobWVyZ2VPcHRpb25zKHRoaXMuX2RlZmF1bHRPcHRpb25zLm1lcmdlKG5ldyBSZXF1ZXN0T3B0aW9ucyh7IGJvZHk6IGJvZHkgfSkpLCBvcHRpb25zLCBSZXF1ZXN0TWV0aG9kLlB1dCwgdXJsKSkpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUGVyZm9ybXMgYSByZXF1ZXN0IHdpdGggYGRlbGV0ZWAgaHR0cCBtZXRob2QuXG4gICAgICAgICAqIEBwYXJhbSB7P30gdXJsXG4gICAgICAgICAqIEBwYXJhbSB7Pz19IG9wdGlvbnNcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIEh0dHAucHJvdG90eXBlLmRlbGV0ZSA9IGZ1bmN0aW9uICh1cmwsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3QobmV3IFJlcXVlc3QobWVyZ2VPcHRpb25zKHRoaXMuX2RlZmF1bHRPcHRpb25zLCBvcHRpb25zLCBSZXF1ZXN0TWV0aG9kLkRlbGV0ZSwgdXJsKSkpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUGVyZm9ybXMgYSByZXF1ZXN0IHdpdGggYHBhdGNoYCBodHRwIG1ldGhvZC5cbiAgICAgICAgICogQHBhcmFtIHs/fSB1cmxcbiAgICAgICAgICogQHBhcmFtIHs/fSBib2R5XG4gICAgICAgICAqIEBwYXJhbSB7Pz19IG9wdGlvbnNcbiAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICovXG4gICAgICAgIEh0dHAucHJvdG90eXBlLnBhdGNoID0gZnVuY3Rpb24gKHVybCwgYm9keSwgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdChuZXcgUmVxdWVzdChtZXJnZU9wdGlvbnModGhpcy5fZGVmYXVsdE9wdGlvbnMubWVyZ2UobmV3IFJlcXVlc3RPcHRpb25zKHsgYm9keTogYm9keSB9KSksIG9wdGlvbnMsIFJlcXVlc3RNZXRob2QuUGF0Y2gsIHVybCkpKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFBlcmZvcm1zIGEgcmVxdWVzdCB3aXRoIGBoZWFkYCBodHRwIG1ldGhvZC5cbiAgICAgICAgICogQHBhcmFtIHs/fSB1cmxcbiAgICAgICAgICogQHBhcmFtIHs/PX0gb3B0aW9uc1xuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgSHR0cC5wcm90b3R5cGUuaGVhZCA9IGZ1bmN0aW9uICh1cmwsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3QobmV3IFJlcXVlc3QobWVyZ2VPcHRpb25zKHRoaXMuX2RlZmF1bHRPcHRpb25zLCBvcHRpb25zLCBSZXF1ZXN0TWV0aG9kLkhlYWQsIHVybCkpKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFBlcmZvcm1zIGEgcmVxdWVzdCB3aXRoIGBvcHRpb25zYCBodHRwIG1ldGhvZC5cbiAgICAgICAgICogQHBhcmFtIHs/fSB1cmxcbiAgICAgICAgICogQHBhcmFtIHs/PX0gb3B0aW9uc1xuICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgKi9cbiAgICAgICAgSHR0cC5wcm90b3R5cGUub3B0aW9ucyA9IGZ1bmN0aW9uICh1cmwsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3QobmV3IFJlcXVlc3QobWVyZ2VPcHRpb25zKHRoaXMuX2RlZmF1bHRPcHRpb25zLCBvcHRpb25zLCBSZXF1ZXN0TWV0aG9kLk9wdGlvbnMsIHVybCkpKTtcbiAgICAgICAgfTtcbiAgICAgICAgSHR0cC5kZWNvcmF0b3JzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLkluamVjdGFibGUgfSxcbiAgICAgICAgXTtcbiAgICAgICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgICAgIEh0dHAuY3RvclBhcmFtZXRlcnMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXG4gICAgICAgICAgICB7IHR5cGU6IENvbm5lY3Rpb25CYWNrZW5kLCB9LFxuICAgICAgICAgICAgeyB0eXBlOiBSZXF1ZXN0T3B0aW9ucywgfSxcbiAgICAgICAgXTsgfTtcbiAgICAgICAgcmV0dXJuIEh0dHA7XG4gICAgfSgpKTtcbiAgICAvKipcbiAgICAgKiBcXEBleHBlcmltZW50YWxcbiAgICAgKi9cbiAgICB2YXIgSnNvbnAgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMkNChKc29ucCwgX3N1cGVyKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7P30gYmFja2VuZFxuICAgICAgICAgKiBAcGFyYW0gez99IGRlZmF1bHRPcHRpb25zXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBKc29ucChiYWNrZW5kLCBkZWZhdWx0T3B0aW9ucykge1xuICAgICAgICAgICAgX3N1cGVyLmNhbGwodGhpcywgYmFja2VuZCwgZGVmYXVsdE9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQZXJmb3JtcyBhbnkgdHlwZSBvZiBodHRwIHJlcXVlc3QuIEZpcnN0IGFyZ3VtZW50IGlzIHJlcXVpcmVkLCBhbmQgY2FuIGVpdGhlciBiZSBhIHVybCBvclxuICAgICAgICAgKiBhIHtcXEBsaW5rIFJlcXVlc3R9IGluc3RhbmNlLiBJZiB0aGUgZmlyc3QgYXJndW1lbnQgaXMgYSB1cmwsIGFuIG9wdGlvbmFsIHtcXEBsaW5rIFJlcXVlc3RPcHRpb25zfVxuICAgICAgICAgKiBvYmplY3QgY2FuIGJlIHByb3ZpZGVkIGFzIHRoZSAybmQgYXJndW1lbnQuIFRoZSBvcHRpb25zIG9iamVjdCB3aWxsIGJlIG1lcmdlZCB3aXRoIHRoZSB2YWx1ZXNcbiAgICAgICAgICogb2Yge1xcQGxpbmsgQmFzZVJlcXVlc3RPcHRpb25zfSBiZWZvcmUgcGVyZm9ybWluZyB0aGUgcmVxdWVzdC5cbiAgICAgICAgICpcbiAgICAgICAgICogXFxAc2VjdXJpdHkgUmVndWxhciBYSFIgaXMgdGhlIHNhZmVzdCBhbHRlcm5hdGl2ZSB0byBKU09OUCBmb3IgbW9zdCBhcHBsaWNhdGlvbnMsIGFuZCBpc1xuICAgICAgICAgKiBzdXBwb3J0ZWQgYnkgYWxsIGN1cnJlbnQgYnJvd3NlcnMuIEJlY2F1c2UgSlNPTlAgY3JlYXRlcyBhIGA8c2NyaXB0PmAgZWxlbWVudCB3aXRoXG4gICAgICAgICAqIGNvbnRlbnRzIHJldHJpZXZlZCBmcm9tIGEgcmVtb3RlIHNvdXJjZSwgYXR0YWNrZXItY29udHJvbGxlZCBkYXRhIGludHJvZHVjZWQgYnkgYW4gdW50cnVzdGVkXG4gICAgICAgICAqIHNvdXJjZSBjb3VsZCBleHBvc2UgeW91ciBhcHBsaWNhdGlvbiB0byBYU1Mgcmlza3MuIERhdGEgZXhwb3NlZCBieSBKU09OUCBtYXkgYWxzbyBiZVxuICAgICAgICAgKiByZWFkYWJsZSBieSBtYWxpY2lvdXMgdGhpcmQtcGFydHkgd2Vic2l0ZXMuIEluIGFkZGl0aW9uLCBKU09OUCBpbnRyb2R1Y2VzIHBvdGVudGlhbCByaXNrIGZvclxuICAgICAgICAgKiBmdXR1cmUgc2VjdXJpdHkgaXNzdWVzIChlLmcuIGNvbnRlbnQgc25pZmZpbmcpLiAgRm9yIG1vcmUgZGV0YWlsLCBzZWUgdGhlXG4gICAgICAgICAqIFtTZWN1cml0eSBHdWlkZV0oaHR0cDovL2cuY28vbmcvc2VjdXJpdHkpLlxuICAgICAgICAgKiBAcGFyYW0gez99IHVybFxuICAgICAgICAgKiBAcGFyYW0gez89fSBvcHRpb25zXG4gICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAqL1xuICAgICAgICBKc29ucC5wcm90b3R5cGUucmVxdWVzdCA9IGZ1bmN0aW9uICh1cmwsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHZhciAvKiogQHR5cGUgez99ICovIHJlc3BvbnNlT2JzZXJ2YWJsZTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdXJsID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHVybCA9XG4gICAgICAgICAgICAgICAgICAgIG5ldyBSZXF1ZXN0KG1lcmdlT3B0aW9ucyh0aGlzLl9kZWZhdWx0T3B0aW9ucywgb3B0aW9ucywgUmVxdWVzdE1ldGhvZC5HZXQsIC8qKiBAdHlwZSB7P30gKi8gKHVybCkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh1cmwgaW5zdGFuY2VvZiBSZXF1ZXN0KSB7XG4gICAgICAgICAgICAgICAgaWYgKHVybC5tZXRob2QgIT09IFJlcXVlc3RNZXRob2QuR2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSlNPTlAgcmVxdWVzdHMgbXVzdCB1c2UgR0VUIHJlcXVlc3QgbWV0aG9kLicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXNwb25zZU9ic2VydmFibGUgPSBodHRwUmVxdWVzdCh0aGlzLl9iYWNrZW5kLCB1cmwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgdXJsIHN0cmluZyBvciBSZXF1ZXN0IGluc3RhbmNlLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlT2JzZXJ2YWJsZTtcbiAgICAgICAgfTtcbiAgICAgICAgSnNvbnAuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5JbmplY3RhYmxlIH0sXG4gICAgICAgIF07XG4gICAgICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgICAgICBKc29ucC5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtcbiAgICAgICAgICAgIHsgdHlwZTogQ29ubmVjdGlvbkJhY2tlbmQsIH0sXG4gICAgICAgICAgICB7IHR5cGU6IFJlcXVlc3RPcHRpb25zLCB9LFxuICAgICAgICBdOyB9O1xuICAgICAgICByZXR1cm4gSnNvbnA7XG4gICAgfShIdHRwKSk7XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIF9jcmVhdGVEZWZhdWx0Q29va2llWFNSRlN0cmF0ZWd5KCkge1xuICAgICAgICByZXR1cm4gbmV3IENvb2tpZVhTUkZTdHJhdGVneSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IHhockJhY2tlbmRcbiAgICAgKiBAcGFyYW0gez99IHJlcXVlc3RPcHRpb25zXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBodHRwRmFjdG9yeSh4aHJCYWNrZW5kLCByZXF1ZXN0T3B0aW9ucykge1xuICAgICAgICByZXR1cm4gbmV3IEh0dHAoeGhyQmFja2VuZCwgcmVxdWVzdE9wdGlvbnMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IGpzb25wQmFja2VuZFxuICAgICAqIEBwYXJhbSB7P30gcmVxdWVzdE9wdGlvbnNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGpzb25wRmFjdG9yeShqc29ucEJhY2tlbmQsIHJlcXVlc3RPcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBuZXcgSnNvbnAoanNvbnBCYWNrZW5kLCByZXF1ZXN0T3B0aW9ucyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBtb2R1bGUgdGhhdCBpbmNsdWRlcyBodHRwJ3MgcHJvdmlkZXJzXG4gICAgICpcbiAgICAgKiBcXEBleHBlcmltZW50YWxcbiAgICAgKi9cbiAgICB2YXIgSHR0cE1vZHVsZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIEh0dHBNb2R1bGUoKSB7XG4gICAgICAgIH1cbiAgICAgICAgSHR0cE1vZHVsZS5kZWNvcmF0b3JzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiBfYW5ndWxhcl9jb3JlLk5nTW9kdWxlLCBhcmdzOiBbe1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXJzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETyhwYXNjYWwpOiB1c2UgZmFjdG9yeSB0eXBlIGFubm90YXRpb25zIG9uY2Ugc3VwcG9ydGVkIGluIERJXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaXNzdWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9hbmd1bGFyL2FuZ3VsYXIvaXNzdWVzLzMxODNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IHByb3ZpZGU6IEh0dHAsIHVzZUZhY3Rvcnk6IGh0dHBGYWN0b3J5LCBkZXBzOiBbWEhSQmFja2VuZCwgUmVxdWVzdE9wdGlvbnNdIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgQnJvd3NlclhocixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IHByb3ZpZGU6IFJlcXVlc3RPcHRpb25zLCB1c2VDbGFzczogQmFzZVJlcXVlc3RPcHRpb25zIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBwcm92aWRlOiBSZXNwb25zZU9wdGlvbnMsIHVzZUNsYXNzOiBCYXNlUmVzcG9uc2VPcHRpb25zIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgWEhSQmFja2VuZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IHByb3ZpZGU6IFhTUkZTdHJhdGVneSwgdXNlRmFjdG9yeTogX2NyZWF0ZURlZmF1bHRDb29raWVYU1JGU3RyYXRlZ3kgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgIH0sXSB9LFxuICAgICAgICBdO1xuICAgICAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICAgICAgSHR0cE1vZHVsZS5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtdOyB9O1xuICAgICAgICByZXR1cm4gSHR0cE1vZHVsZTtcbiAgICB9KCkpO1xuICAgIC8qKlxuICAgICAqIFRoZSBtb2R1bGUgdGhhdCBpbmNsdWRlcyBqc29ucCdzIHByb3ZpZGVyc1xuICAgICAqXG4gICAgICogXFxAZXhwZXJpbWVudGFsXG4gICAgICovXG4gICAgdmFyIEpzb25wTW9kdWxlID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gSnNvbnBNb2R1bGUoKSB7XG4gICAgICAgIH1cbiAgICAgICAgSnNvbnBNb2R1bGUuZGVjb3JhdG9ycyA9IFtcbiAgICAgICAgICAgIHsgdHlwZTogX2FuZ3VsYXJfY29yZS5OZ01vZHVsZSwgYXJnczogW3tcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyczogW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE8ocGFzY2FsKTogdXNlIGZhY3RvcnkgdHlwZSBhbm5vdGF0aW9ucyBvbmNlIHN1cHBvcnRlZCBpbiBESVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlzc3VlOiBodHRwczovL2dpdGh1Yi5jb20vYW5ndWxhci9hbmd1bGFyL2lzc3Vlcy8zMTgzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBwcm92aWRlOiBKc29ucCwgdXNlRmFjdG9yeToganNvbnBGYWN0b3J5LCBkZXBzOiBbSlNPTlBCYWNrZW5kLCBSZXF1ZXN0T3B0aW9uc10gfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBCcm93c2VySnNvbnAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBwcm92aWRlOiBSZXF1ZXN0T3B0aW9ucywgdXNlQ2xhc3M6IEJhc2VSZXF1ZXN0T3B0aW9ucyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgcHJvdmlkZTogUmVzcG9uc2VPcHRpb25zLCB1c2VDbGFzczogQmFzZVJlc3BvbnNlT3B0aW9ucyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgcHJvdmlkZTogSlNPTlBCYWNrZW5kLCB1c2VDbGFzczogSlNPTlBCYWNrZW5kXyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgfSxdIH0sXG4gICAgICAgIF07XG4gICAgICAgIC8qKiBAbm9jb2xsYXBzZSAqL1xuICAgICAgICBKc29ucE1vZHVsZS5jdG9yUGFyYW1ldGVycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtdOyB9O1xuICAgICAgICByZXR1cm4gSnNvbnBNb2R1bGU7XG4gICAgfSgpKTtcblxuICAgIC8qKlxuICAgICAqIEBzdGFibGVcbiAgICAgKi9cbiAgICB2YXIgLyoqIEB0eXBlIHs/fSAqLyBWRVJTSU9OID0gbmV3IF9hbmd1bGFyX2NvcmUuVmVyc2lvbignMi40LjEwJyk7XG5cbiAgICBleHBvcnRzLkJyb3dzZXJYaHIgPSBCcm93c2VyWGhyO1xuICAgIGV4cG9ydHMuSlNPTlBCYWNrZW5kID0gSlNPTlBCYWNrZW5kO1xuICAgIGV4cG9ydHMuSlNPTlBDb25uZWN0aW9uID0gSlNPTlBDb25uZWN0aW9uO1xuICAgIGV4cG9ydHMuQ29va2llWFNSRlN0cmF0ZWd5ID0gQ29va2llWFNSRlN0cmF0ZWd5O1xuICAgIGV4cG9ydHMuWEhSQmFja2VuZCA9IFhIUkJhY2tlbmQ7XG4gICAgZXhwb3J0cy5YSFJDb25uZWN0aW9uID0gWEhSQ29ubmVjdGlvbjtcbiAgICBleHBvcnRzLkJhc2VSZXF1ZXN0T3B0aW9ucyA9IEJhc2VSZXF1ZXN0T3B0aW9ucztcbiAgICBleHBvcnRzLlJlcXVlc3RPcHRpb25zID0gUmVxdWVzdE9wdGlvbnM7XG4gICAgZXhwb3J0cy5CYXNlUmVzcG9uc2VPcHRpb25zID0gQmFzZVJlc3BvbnNlT3B0aW9ucztcbiAgICBleHBvcnRzLlJlc3BvbnNlT3B0aW9ucyA9IFJlc3BvbnNlT3B0aW9ucztcbiAgICBleHBvcnRzLlJlYWR5U3RhdGUgPSBSZWFkeVN0YXRlO1xuICAgIGV4cG9ydHMuUmVxdWVzdE1ldGhvZCA9IFJlcXVlc3RNZXRob2Q7XG4gICAgZXhwb3J0cy5SZXNwb25zZUNvbnRlbnRUeXBlID0gUmVzcG9uc2VDb250ZW50VHlwZTtcbiAgICBleHBvcnRzLlJlc3BvbnNlVHlwZSA9IFJlc3BvbnNlVHlwZTtcbiAgICBleHBvcnRzLkhlYWRlcnMgPSBIZWFkZXJzO1xuICAgIGV4cG9ydHMuSHR0cCA9IEh0dHA7XG4gICAgZXhwb3J0cy5Kc29ucCA9IEpzb25wO1xuICAgIGV4cG9ydHMuSHR0cE1vZHVsZSA9IEh0dHBNb2R1bGU7XG4gICAgZXhwb3J0cy5Kc29ucE1vZHVsZSA9IEpzb25wTW9kdWxlO1xuICAgIGV4cG9ydHMuQ29ubmVjdGlvbiA9IENvbm5lY3Rpb247XG4gICAgZXhwb3J0cy5Db25uZWN0aW9uQmFja2VuZCA9IENvbm5lY3Rpb25CYWNrZW5kO1xuICAgIGV4cG9ydHMuWFNSRlN0cmF0ZWd5ID0gWFNSRlN0cmF0ZWd5O1xuICAgIGV4cG9ydHMuUmVxdWVzdCA9IFJlcXVlc3Q7XG4gICAgZXhwb3J0cy5SZXNwb25zZSA9IFJlc3BvbnNlO1xuICAgIGV4cG9ydHMuUXVlcnlFbmNvZGVyID0gUXVlcnlFbmNvZGVyO1xuICAgIGV4cG9ydHMuVVJMU2VhcmNoUGFyYW1zID0gVVJMU2VhcmNoUGFyYW1zO1xuICAgIGV4cG9ydHMuVkVSU0lPTiA9IFZFUlNJT047XG5cbn0pKTsiXX0=